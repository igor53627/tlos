// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import {SSTORE2} from "solmate/utils/SSTORE2.sol";
import "../contracts/TLOSWithPuzzleV3.sol";

/// @title TLOS Integration Test
/// @notice End-to-end test using pre-generated circuit data from Rust
/// @dev To generate test vectors, run:
///      cargo run --bin generate_tlos -- --secret 0x...1234 --seed 42 --output test/fixtures/circuit.bin
contract TLOSIntegrationTest is Test {
    // Test vector: secret = 0x0000...1234, seed = 42
    // Generated by: cargo run --bin generate_tlos
    bytes32 constant TEST_SECRET = bytes32(uint256(0x1234));
    bytes32 constant CIRCUIT_SEED = bytes32(uint256(42));
    bytes32 constant EXPECTED_OUTPUT_HASH = 0x2efc09b3a8ba82d06cb0ac59bb0a8543fb1b32026194578e20f3074597306143;
    
    // Expected binding output (from Rust generator, converted to uint256)
    // Format: lo|hi u128 pairs -> uint256 = hi << 128 | lo
    uint256 constant EXPECTED_BINDING_0 = 0x5f256026215d1d5aedf2f3e24191b92ad4fb42d1d57ac242b122cfdfd7f58bca;
    uint256 constant EXPECTED_BINDING_1 = 0xc363d23a37a81bbd9419457fed2baa16390603e4185282dd0a3eec925a64c506;
    uint256 constant EXPECTED_BINDING_2 = 0xaf6ce891ae1825ce02f2e87a2add8b6b95224e510359a61c3164b4afb0f77c97;
    uint256 constant EXPECTED_BINDING_3 = 0xdc83b56cc4b04533e650a321ec33d4361c128a99e9cdbf281a670384f9dd9b1e;
    
    TLOSWithPuzzleV3 public honeypot;
    
    // Allow test contract to receive ETH
    receive() external payable {}
    
    function setUp() public {
        // Generate mock circuit data (in real use, load from Rust-generated file)
        // Using 64 gates to keep test fast (real deployments use 640)
        bytes memory circuitData = _generateMockCircuitData(64);
        address dataPtr = SSTORE2.write(circuitData);
        
        uint256[4] memory expectedBinding = [
            EXPECTED_BINDING_0,
            EXPECTED_BINDING_1,
            EXPECTED_BINDING_2,
            EXPECTED_BINDING_3
        ];
        
        honeypot = new TLOSWithPuzzleV3(
            dataPtr,
            64,                    // numWires
            64,                    // numGates (reduced for test speed)
            EXPECTED_OUTPUT_HASH,
            CIRCUIT_SEED,
            expectedBinding,
            block.timestamp + 1 days
        );
    }
    
    function test_GetPlantedSecret() public view {
        int8[48] memory secret = honeypot.getPlantedSecret(TEST_SECRET);
        
        // Verify secret is ternary {-1, 0, 1}
        for (uint i = 0; i < 48; i++) {
            assertTrue(secret[i] >= -1 && secret[i] <= 1, "Secret must be ternary");
        }
    }
    
    function test_PuzzleVerification() public view {
        int8[48] memory puzzleSolution = honeypot.getPlantedSecret(TEST_SECRET);
        
        // checkWithPuzzle should not revert (puzzle solution is valid)
        // Note: Will return false because mock circuit data doesn't produce correct output
        honeypot.checkWithPuzzle(TEST_SECRET, puzzleSolution);
    }
    
    function test_WrongSecretFails() public view {
        bytes32 wrongSecret = bytes32(uint256(0x5678));
        int8[48] memory puzzleSolution = honeypot.getPlantedSecret(wrongSecret);
        
        // Should return false (wrong secret)
        bool valid = honeypot.checkWithPuzzle(wrongSecret, puzzleSolution);
        assertFalse(valid, "Wrong secret should fail");
    }
    
    function test_CommitRevealFlow() public {
        address solver = makeAddr("solver");
        vm.deal(solver, 1 ether);
        
        int8[48] memory puzzleSolution = honeypot.getPlantedSecret(TEST_SECRET);
        bytes32 commitHash = keccak256(abi.encode(solver, TEST_SECRET, puzzleSolution));
        
        // Commit
        vm.prank(solver);
        honeypot.commit(commitHash);
        
        (bytes32 storedHash, uint256 blockNum) = honeypot.getCommit(solver);
        assertEq(storedHash, commitHash, "Commit hash mismatch");
        assertEq(blockNum, block.number, "Block number mismatch");
        
        // Wait for delay
        vm.roll(block.number + 3);
        
        // Reveal would fail because mock circuit data, but commit logic is tested
    }
    
    function test_ExpiryReclaim() public {
        address owner = honeypot.owner();
        
        // Fund the contract via receive()
        (bool sent,) = address(honeypot).call{value: 1 ether}("");
        assertTrue(sent, "Failed to fund contract");
        
        uint256 balanceAfterFunding = owner.balance;
        
        // Fast forward past expiry
        vm.warp(honeypot.secretExpiry() + 1);
        
        // Reclaim
        vm.prank(owner);
        honeypot.reclaimExpired();
        
        // Owner should receive the 1 ether back
        assertEq(owner.balance, balanceAfterFunding + 1 ether, "Owner should receive funds");
    }
    
    function test_GasEstimates() public {
        int8[48] memory puzzleSolution = honeypot.getPlantedSecret(TEST_SECRET);
        
        uint256 gasBefore = gasleft();
        honeypot.checkWithPuzzle(TEST_SECRET, puzzleSolution);
        uint256 gasUsed = gasBefore - gasleft();
        
        emit log_named_uint("checkWithPuzzle gas", gasUsed);
        emit log_named_uint("% of 60M block", gasUsed * 100 / 60_000_000);
        
        // Should be under 20% of block limit
        assertLt(gasUsed, 12_000_000, "Gas should be under 20% of block");
    }
    
    // Generate mock circuit data for testing
    // In production, use Rust-generated data
    function _generateMockCircuitData(uint32 numGates) internal pure returns (bytes memory) {
        uint256 ctSize = 384 * 2 + 2;  // n=384
        uint256 gateSize = 3 + 4 * ctSize;
        bytes memory data = new bytes(numGates * gateSize);
        
        for (uint32 g = 0; g < numGates; g++) {
            uint256 baseOffset = g * gateSize;
            
            data[baseOffset] = bytes1(uint8((g * 3) % 64));
            data[baseOffset + 1] = bytes1(uint8((g * 5 + 1) % 64));
            data[baseOffset + 2] = bytes1(uint8((g * 7 + 2) % 64));
            
            for (uint256 tt = 0; tt < 4; tt++) {
                uint256 ctOffset = baseOffset + 3 + tt * ctSize;
                
                for (uint256 i = 0; i < 384; i++) {
                    uint16 ai = uint16((g * 1337 + tt * 31 + i * 17) % 65521);
                    data[ctOffset + i * 2] = bytes1(uint8(ai >> 8));
                    data[ctOffset + i * 2 + 1] = bytes1(uint8(ai & 0xFF));
                }
                
                bool expectedBit = ((g + tt) % 2) == 1;
                uint16 b = expectedBit ? uint16(32760) : 0;
                b = uint16((uint256(b) + (g * tt) % 16) % 65521);
                data[ctOffset + 384 * 2] = bytes1(uint8(b >> 8));
                data[ctOffset + 384 * 2 + 1] = bytes1(uint8(b & 0xFF));
            }
        }
        
        return data;
    }
}
