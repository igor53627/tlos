\documentclass[10pt,a4paper,twocolumn]{article}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue]{hyperref}
\geometry{a4paper,top=25mm,bottom=25mm,left=19mm,right=19mm,columnsep=8mm}

\input{macros}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\lstset{
  basicstyle=\ttfamily\scriptsize,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray}\itshape,
  breaklines=true,
  frame=single,
  columns=fullflexible,
  upquote=true,
}

\title{\tlo{}: Topology-Lattice Obfuscation for Smart Contracts}
\author{
\textit{Anonymous Submission}
}
\date{}

\begin{document}
\maketitle

\begin{abstract}
We present \tlo{} (Topology-Lattice Obfuscation), a practical circuit obfuscation framework for smart contracts. Security derives from a two-layer defense: a topology layer using structural mixing defeats structural and statistical attacks (empirically validated), while the \lwe{} layer computes inner products on-chain to hide control functions. Security is based on uniform-secret \lwe{} hardness (${\sim}108$-bit classical with $n{=}64$, $\sigma{=}1024$; see \S\ref{sec:security-estimates}) combined with topology properties, providing post-quantum resistance (assuming \lwe{} quantum-resistance).

\tlo{} achieves 6/6 resistance against our attack evaluation matrix at ${\sim}2.58$M gas (8.6\% of block limit). Control functions are hidden via \lwe{} ciphertexts where the key $s_{\mathrm{enc}} = H(\mathsf{secret})$ is derived from the secret at encryption time; at evaluation, the contract derives $s(x) = H(x)$ from the candidate input---matching only when $x = \mathsf{secret}$. Attackers \emph{can} simulate evaluation with arbitrary keys, but incorrect keys yield garbage outputs. The 1-bit oracle interface limits information leakage. Target applications include predicates with eventually-expiring secrets (honeypots, sealed-bid auctions, lotteries). Deployment requires only a standard smart contract with expiry timestamp.
\end{abstract}

%------------------------------------------------------------------------------
\section{Introduction}
%------------------------------------------------------------------------------

Smart contracts are fully transparent. Anyone can read bytecode, analyze logic, and exploit vulnerabilities. This conflicts with applications requiring hidden logic: cryptographic honeypots, MEV-resistant execution, sealed-bid auctions, and private liquidation thresholds.

Indistinguishability obfuscation (iO) provides permanent security but requires impractical overhead ($10^6\times$). We take a different approach: \emph{practical obfuscation} that resists known attack classes through two complementary layers:

\begin{center}
\framebox{\parbox{0.85\columnwidth}{
\textbf{Two-Layer Security Model:}
\begin{enumerate}
\item \textbf{Layer 1 (Topology):} Structural mixing defeats structural/statistical attacks. \emph{Security: heuristic.}
\item \textbf{Layer 2 (\lwe{}):} On-chain inner products defeat semantic attacks. \emph{Security: computational (${\sim}108$-bit with $\sigma{=}1024$).}
\end{enumerate}
\textbf{Key mechanism:} 1-bit oracle + wrong-key-gives-garbage property.
}}
\end{center}

\subsection{Contributions}

\begin{enumerate}
\item \textbf{\tlo{} Framework:} Two-layer obfuscation combining topology mixing with on-chain \lwe{} inner products (${\sim}2.58$M gas for $n{=}64$).
\item \textbf{Structural Mixing:} Wire selection defeating structural/statistical attacks (heuristic, empirically validated).
\item \textbf{Oracle + Wrong-Key-Garbage:} Attackers \emph{can} simulate with arbitrary keys, but incorrect keys yield garbage; 1-bit oracle limits information leakage.
\item \textbf{On-Chain \lwe{}:} Control functions hidden via \lwe{} ciphertexts with full inner product computation.
\item \textbf{Post-Quantum Security:} ${\sim}108$-bit classical via uniform-secret \lwe{} ($n{=}64$, $\sigma{=}1024$); ${\sim}203$-bit for $n{=}128$; see \S\ref{sec:security-estimates}.
\end{enumerate}

\subsection{Scope}

\textbf{We claim:} Security based on \lwe{} hardness + topology heuristics; 6/6 attack resistance in our matrix; post-quantum resistance.

\textbf{We do NOT claim:} iO security; universal security.

%------------------------------------------------------------------------------
\section{Preliminaries}
%------------------------------------------------------------------------------

\subsection{Learning With Errors}

\begin{definition}[\lwe{}~\cite{Regev05}]
For dimension $n$, modulus $q$, and error distribution $\chi$, the \lwe{} problem is: given $(A, As + e \mod q)$ where $A \in \mathbb{Z}_q^{m \times n}$, $s \in \mathbb{Z}_q^n$, $e \leftarrow \chi^m$, distinguish from uniform $(A, u)$.
\end{definition}

\lwe{} is believed quantum-resistant and forms the basis for post-quantum cryptography standards (ML-KEM)~\cite{FIPS203}. Our parameters ($n{=}64$, $q{=}65521$) are smaller than NIST profiles; see \S\ref{sec:security-estimates} for security estimates.

\subsection{LWE Control Function Hiding}

We hide each gate's control function via \lwe{} ciphertexts. Each CF bit is encoded as $(a, b)$ where $b = \langle a, s_{\mathrm{enc}} \rangle + e + \mathsf{bit} \cdot q/2$. At encryption time, $s_{\mathrm{enc}} = H(\mathsf{secret})$. At evaluation time, the contract derives $s(x) = H(x)$ from the candidate input---decryption succeeds iff $x = \mathsf{secret}$.

\subsection{Reversible Circuits}

\begin{definition}[Reversible Gate]
A gate $g = (a, c_1, c_2, c_f)$ operates on $n$ wires: active wire $a$ is XORed with $c_f(c_1, c_2)$ where $c_f: \{0,1\}^2 \to \{0,1\}$ is one of 16 control functions.
\end{definition}

Gates are self-inverse: $g(g(s)) = s$. This enables commit-reveal protocols where the solver demonstrates knowledge without revealing the secret.

%------------------------------------------------------------------------------
\section{The Topology Layer}
%------------------------------------------------------------------------------

The topology layer is a reversible circuit mixing design that defeats structural and statistical attacks through wire selection, without cryptographic primitives.

\subsection{Wire Selection Algorithm}

Structural mixing selects wires to defeat pattern detection:

\begin{enumerate}
\item \textbf{Non-pow2 distances:} Control wires at distances $d \notin \{1, 2, 4, 8, \ldots\}$ from active wire defeats butterfly/FFT pattern detection
\item \textbf{Uniform wire usage:} Prefer underused wires; defeats chi-squared statistical attacks
\item \textbf{Irregular layers:} Varying gates per layer (e.g., 30--70 for 256 wires) defeats regularity detection
\item \textbf{64+ wires:} Sufficient width defeats diagonal correlation (Pearson $r < 0.10$)
\end{enumerate}

\begin{lstlisting}[language=Python,caption=Wire Selection (pseudocode)]
def select_control_wire(active, usage, target):
    # Choose non-pow2 distance
    d = random_choice(non_pow2_distances)
    candidate = (active + d) % num_wires
    
    # Prefer underused wires (70% prob)
    if random() < 0.7 and usage[candidate] < target:
        return candidate
    
    # Otherwise, find underused alternative
    return find_underused_wire(usage, target)
\end{lstlisting}

\subsection{Topology Attack Resistance}

\begin{table}[!ht]
\centering
\scriptsize
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Attack} & \textbf{Type} & \textbf{Defense} & \textbf{Mechanism} \\
\midrule
Compression & Structural & Topology & No duplicate gates \\
PatternMatch & Structural & Topology & Random CF cycling \\
Structural & Structural & Topology & Non-pow2 distances \\
Statistical & Statistical & Topology & Uniform wire usage \\
DiagCorrelation & Statistical & Topology & 64+ wires \\
\bottomrule
\end{tabular}
\caption{Topology defeats structural/statistical attacks.}
\label{tab:topology-attacks}
\end{table}

\textbf{Key insight:} Unlike butterfly or derangement topologies that only rearrange gates, structural mixing has anti-attack properties \emph{built into wire selection}.

%------------------------------------------------------------------------------
\section{\lwe{} for Semantic Attacks}
%------------------------------------------------------------------------------

\subsection{The RainbowTable Problem}

RainbowTable is a \emph{semantic} attack---it matches truth-table behavior, not structure:

\begin{enumerate}
\item Extract subcircuit from obfuscated circuit
\item Evaluate subcircuit on sample inputs
\item Match behavior against pre-computed lookup table
\end{enumerate}

Topology cannot defeat this. Any structural transformation preserves semantic behavior of reversible circuits.

\subsection{How \lwe{} Blocks RainbowTable}

Attackers \emph{can} simulate evaluation with arbitrary keys---this is not a restricted oracle. The defense is the \textbf{wrong-key-gives-garbage} property: incorrect keys yield random CF bits, producing garbage outputs.

\begin{center}
\framebox{\parbox{0.85\columnwidth}{
\textbf{On-Chain Inner Product:} Control functions encoded as \lwe{} ciphertexts $(a, b)$. At encryption: $s_{\mathrm{enc}} = H(\mathsf{secret})$. At evaluation: $s(x) = H(x)$.

\textbf{Key mechanism:} Attackers can simulate with any $s'$, but $s' \neq s_{\mathrm{enc}}$ yields garbage CF bits. Combined with 1-bit output, this limits information leakage.
}}
\end{center}

\begin{proposition}[\lwe{} Security]
Under \lwe{} hardness, no \ppt{} adversary can evaluate a subcircuit in isolation.
\end{proposition}

\textit{Proof sketch:} Each CF is hidden via \lwe{} ciphertext. Subcircuit evaluation requires recovering CF bits, which reduces to \lwe{} hardness. $\square$

%------------------------------------------------------------------------------
\section{Security Analysis}
%------------------------------------------------------------------------------

\subsection{Two-Layer Security Model}

\tlo{} provides security through complementary layers with different bases:

\begin{enumerate}
\item \textbf{Topology layer (heuristic):} Defeats structural/statistical attacks through wire selection. \emph{Empirically validated, not proven.}

\item \textbf{\lwe{} layer (computational):} Defeats semantic attacks via on-chain inner products. \emph{Based on \lwe{} hardness (${\sim}49$-bit with $n{=}64$; see \S\ref{sec:security-estimates}).}

\item \textbf{Wrong-key-gives-garbage:} Attackers can simulate with arbitrary keys, but incorrect keys yield garbage outputs. Combined with 1-bit oracle.
\end{enumerate}

\begin{definition}[Extraction Resistance]
An obfuscator $\obf$ is extraction resistant if no \ppt{} adversary can extract exploitable information from $\obf(C)$ with non-negligible probability.
\end{definition}

\begin{theorem}[\tlo{} Attack Resistance]
Under \lwe{} hardness, topology empirical security, and the wrong-key-gives-garbage property (1-bit on-chain oracle), \tlo{} achieves extraction resistance against our 6-class attack matrix.
\end{theorem}

\textit{Proof:} Structural/statistical attacks are defeated by the topology layer (empirical). RainbowTable requires subcircuit evaluation, blocked by \lwe{} CF hiding. $\square$

\subsection{Attack Evaluation Matrix}

\begin{table}[!ht]
\centering
\scriptsize
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Attack} & \textbf{Defense} & \textbf{Basis} & \textbf{Status} \\
\midrule
Compression & Topology & Structural & \textsc{Blocked} \\
PatternMatch & Topology & Structural & \textsc{Blocked} \\
Structural & Topology & Structural & \textsc{Blocked} \\
Statistical & Topology & Statistical & \textsc{Blocked} \\
DiagCorrelation & Topology & Statistical & \textsc{Blocked} \\
RainbowTable & \lwe{} & Semantic & \textsc{Blocked} \\
\bottomrule
\end{tabular}
\caption{\tlo{} attack resistance (empirical, not universal).}
\label{tab:attack-matrix}
\end{table}

\subsection{Security Estimates}\label{sec:security-estimates}

\textbf{Uniform-Secret \lwe{}.} \tlo{} derives the \lwe{} secret as $s_{\mathsf{enc}} = H(\mathsf{secret})$, producing a \emph{uniform} secret over $\mathbb{Z}_q^n$ rather than a small-coefficient secret. This variant is \emph{harder} to attack: primal (uSVP) attacks fail when $\|s\| \approx \sqrt{n} \cdot q/2$. We validated this via BKZ attacks using fpylll---BKZ-50 on $n{=}16$ failed after 200+ iterations.

Using the official \texttt{lattice-estimator} with our parameters ($n{=}64$, $q{=}65521$, $\sigma{=}1024$), we obtain ${\sim}108$-bit classical security via BDD attack analysis. The larger noise ($\sigma{=}1024$ vs.\ $\sqrt{q}/4{\approx}64$) is safe because $\sigma \ll q/4{=}16380$, ensuring negligible decryption error. For $n{=}32$: ${\sim}51$-bit; for $n{=}128$: ${\sim}203$-bit.

\textbf{Hash-Compare Baseline:} A simple \texttt{H(secret) == H(input)} check costs ${\sim}45$K gas but provides \emph{no} obfuscation---the predicate structure is visible on-chain. \tlo{} hides control functions at $57\times$ gas cost.

\textbf{Multi-Bit Output: The Key Distinction.} Hash-compare returns a 1-bit output (true/false). \tlo{} circuits compute an $N$-bit output that can encode hidden parameters, computed results, or payloads revealed only on correct input. Both implement \emph{point functions}---predicates meaningful only at $x = \mathsf{secret}$---but \tlo{} provides a hidden payload, not just confirmation.

\begin{center}
\scriptsize
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Approach} & \textbf{Output} & \textbf{What's Hidden} \\
\midrule
Hash-compare & 1 bit & Secret value only \\
\tlo{} & $N$ bits & Secret + hidden computation \\
\bottomrule
\end{tabular}
\end{center}

The $57\times$ gas premium buys multi-bit hidden computation, not stronger unlocking security. Use \tlo{} when the payload matters; use hash-compare for simple confirmation.

\subsection{Post-Quantum Security}

\tlo{} is post-quantum resistant (assuming \lwe{} quantum-resistance):

\begin{itemize}
\item \textbf{Topology layer:} No cryptographic assumptions
\item \textbf{Lattice layer:} \lwe{} is believed quantum-resistant
\end{itemize}

\subsection{Assumptions}

\begin{enumerate}
\item \textbf{\lwe{} hardness:} Learning With Errors is computationally hard.
\item \textbf{Topology empirical security:} Wire selection defeats structural attacks in our evaluation (heuristic, not proven).
\item \textbf{Contract correctness:} Expiry logic is correctly implemented.
\end{enumerate}

%------------------------------------------------------------------------------
\section{Implementation}
%------------------------------------------------------------------------------

\subsection{Contract Architecture}

\tlo{} requires no external infrastructure---just a standard smart contract with timestamp-based expiry:

\begin{lstlisting}[caption=TLOHoneypot Contract,float=!ht]
contract TLOHoneypot {
  uint256 public secretExpiry;
  bytes32 public commitHash;
  
  function check(bytes32 s) external view 
      returns (bool) {
    require(block.timestamp < secretExpiry);
    return evaluate(s);
  }
  
  function commit(bytes32 h) external {
    commitHash = h;
  }
  
  function reveal(bytes32 s) external {
    require(keccak256(abi.encode(s, 
        msg.sender)) == commitHash);
    require(evaluate(s));
    // Transfer reward
  }
}
\end{lstlisting}

\textbf{Deployment:} Set \texttt{secretExpiry} at deployment.

\subsection{Gas Costs}

Measured on 64-wire/640-gate circuits (Tenderly-confirmed):

\begin{table}[!ht]
\centering
\scriptsize
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{\lwe{} $n$} & \textbf{Security ($\sigma{=}1024$)} & \textbf{Gas} & \textbf{Block \%} \\
\midrule
32 & ${\sim}51$-bit & 1.27M & 4.2\% \\
\textbf{64} & \textbf{${\sim}108$-bit} & \textbf{2.58M} & \textbf{8.6\%} \\
96 & ${\sim}178$-bit & 3.0M & 10.0\% \\
128 & ${\sim}203$-bit & 3.8M & 12.7\% \\
\bottomrule
\end{tabular}
\caption{Gas costs by \lwe{} dimension ($\sigma{=}1024$, validated via \texttt{lattice-estimator}).}
\end{table}

%------------------------------------------------------------------------------
\section{Evaluation}
%------------------------------------------------------------------------------

\subsection{Attack Resistance}

We evaluated \tlo{} against 14 attack implementations across 6 attack classes. All configurations achieve 6/6 resistance:

\begin{center}
\scriptsize
\begin{tabular}{@{}lccl@{}}
\toprule
\textbf{\lwe{} $n$} & \textbf{Score} & \textbf{Gas} & \textbf{Security ($\sigma{=}1024$)} \\
\midrule
32 & 6/6 & 1.27M & ${\sim}51$-bit \\
\textbf{64} & \textbf{6/6} & \textbf{2.58M} & \textbf{${\sim}108$-bit} \\
96 & 6/6 & 3.0M & ${\sim}178$-bit \\
128 & 6/6 & 3.8M & ${\sim}203$-bit \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Comparison with Alternatives}

\begin{center}
\scriptsize
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Property} & \textbf{\tlo{}} & \textbf{iO} & \textbf{TEE} \\
\midrule
Attack resistance & 6/6 & 6/6 & 6/6 \\
Secret keys & None & None & Required \\
Gas (check) & 2.58M & $10^6\times$ & 1$\times$ \\
Infrastructure & None & None & Hardware \\
Post-quantum & Yes & Depends & No \\
Practical & Yes & No & Yes \\
\bottomrule
\end{tabular}
\end{center}

%------------------------------------------------------------------------------
\section{Applications}
%------------------------------------------------------------------------------

\subsection{Valid Applications}

\tlo{} is designed for predicates with \emph{eventually-expiring} secrets:

\begin{itemize}
\item \textbf{Cryptographic honeypots:} Reward condition is burned once triggered
\item \textbf{Sealed-bid auctions:} Bids revealed at settlement
\item \textbf{Lotteries/prediction markets:} Outcomes revealed after close
\item \textbf{MEV protection:} Order flow is short-lived
\item \textbf{Dark pools:} Trade conditions expire quickly
\end{itemize}

\subsection{Invalid Applications}

\tlo{} is \emph{not} intended for long-lived static secrets:

\begin{itemize}
\item Long-term decryption keys
\item Permanent signing keys
\item Static liquidation thresholds
\end{itemize}

%------------------------------------------------------------------------------
\section{Limitations}
%------------------------------------------------------------------------------

\textbf{Theoretical:} Topology security is empirical (heuristic, not proven). We do not claim iO-level indistinguishability.

\textbf{Practical:} \tlo{} with $n{=}64$ \lwe{} requires ${\sim}2.58$M gas (8.6\% of block limit). Lower security configurations available for cost-sensitive applications.

\textbf{What \tlo{} does NOT provide:}
\begin{itemize}
\item Indistinguishability: Two circuits have distinguishable obfuscations
\item Universal security: Only resists our 6 attack classes
\item Forward secrecy: Expired secrets may be analyzed retroactively
\item Security after \lwe{} compromise: If CF bits are recovered, the reversible circuit can be inverted in linear time. Topology only hardens \emph{pre-compromise} attacks
\end{itemize}

%------------------------------------------------------------------------------
\section{Related Work}
%------------------------------------------------------------------------------

\textbf{Indistinguishability Obfuscation:} Theoretical iO~\cite{GGH13,JLS21} provides strong security but requires impractical overhead.

\textbf{Compute-and-Compare:} Goyal-Koppula-Waters~\cite{GKW17} and Wichs-Zirdelis~\cite{WZ17} introduced \cac{} for evasive functions. We apply it to control function hiding.

\textbf{Smart Contract Privacy:} Previous work uses ZK-SNARKs (Tornado Cash) or TEEs (Secret Network). \tlo{} provides a new point in the design space: on-chain obfuscation without trusted hardware.

%------------------------------------------------------------------------------
\section{Conclusion}
%------------------------------------------------------------------------------

\tlo{} provides practical circuit obfuscation for smart contracts through two-layer defense: a topology layer (heuristic) defeats structural/statistical attacks, while on-chain \lwe{} inner products defeat semantic attacks.

\tlo{} achieves 6/6 resistance against our attack matrix at ${\sim}2.58$M gas ($n{=}64$, ${\sim}108$-bit security with $\sigma{=}1024$). Post-quantum resistant (assuming \lwe{} quantum-resistance). Deployment requires only a standard smart contract with timestamp expiry.

\textbf{Key contributions:} On-chain \lwe{} inner products for true CF hiding; wrong-key-gives-garbage property combined with 1-bit oracle interface; discovery that larger noise ($\sigma{=}1024$ vs.\ $\sqrt{q}/4$) provides dramatically higher security at zero additional cost.

Code and attack suite: \url{https://github.com/igor53627/tlo}

%------------------------------------------------------------------------------
\bibliographystyle{abbrv}
\begin{thebibliography}{10}

\bibitem{FIPS203}
{National Institute of Standards and Technology}.
\newblock Module-Lattice-Based Key-Encapsulation Mechanism Standard (ML-KEM).
\newblock NIST FIPS 203, 2024.

\bibitem{GGH13}
S.~Garg, C.~Gentry, S.~Halevi, M.~Raykova, A.~Sahai, and B.~Waters.
\newblock Candidate indistinguishability obfuscation and functional encryption for all circuits.
\newblock In {\em FOCS}, 2013.

\bibitem{GKW17}
R.~Goyal, V.~Koppula, and B.~Waters.
\newblock Lockable obfuscation.
\newblock In {\em FOCS}, 2017.

\bibitem{JLS21}
A.~Jain, H.~Lin, and A.~Sahai.
\newblock Indistinguishability obfuscation from well-founded assumptions.
\newblock In {\em STOC}, 2021.

\bibitem{Regev05}
O.~Regev.
\newblock On lattices, learning with errors, random linear codes, and cryptography.
\newblock In {\em STOC}, 2005.

\bibitem{WZ17}
D.~Wichs and G.~Zirdelis.
\newblock Obfuscating compute-and-compare programs under LWE.
\newblock In {\em FOCS}, 2017.

\bibitem{AlbrechtEstimator}
M.~R. Albrecht, R.~Player, and S.~Scott.
\newblock On the concrete hardness of Learning with Errors.
\newblock {\em Journal of Mathematical Cryptology}, 9(3):169--203, 2015.

\end{thebibliography}

\end{document}
