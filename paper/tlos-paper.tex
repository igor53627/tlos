\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\geometry{margin=1in}

\input{macros}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  breaklines=true,
  frame=single,
  xleftmargin=1em,
  xrightmargin=1em,
  columns=fullflexible,
  keepspaces=true,
  upquote=true,
}

\title{\tlos{}: Topology-Lattice Obfuscation for Smart Contracts}
\author{}
\date{}

\begin{document}
\maketitle

\begin{abstract}
We introduce \tlos{} (Topology-Lattice Obfuscation for Smart Contracts), a four-layer obfuscation architecture designed to protect sensitive logic on public ledgers. Unlike theoretical constructions of Indistinguishability Obfuscation (iO) that are too costly for deployment, \tlos{} relies on standard cryptographic assumptions adapted for the EVM. The framework integrates: (1)~heuristic topology mixing to defeat structural analysis, (2)~an on-chain LWE layer ($n{=}384$, $\sigma{=}8$) to hide control flow, (3)~full-rank linear wire binding to ensure trace integrity, and (4)~a planted ternary LWE puzzle that enforces a computational floor of $2^{76}$ operations per guess. Empirical evaluation confirms \tlos{} resists structural, statistical, and semantic attacks, offering a robust and gas-efficient (11 bytes/gate) solution for on-chain secrets.
\end{abstract}

%------------------------------------------------------------------------------
\section{Introduction}
%------------------------------------------------------------------------------

Smart contracts on public blockchains are fully transparent: anyone can read the bytecode, analyze the logic, and exploit vulnerabilities before the contract owner can react. This transparency fundamentally conflicts with applications requiring hidden logic or \emph{low-entropy secret protection}:

\begin{itemize}
  \item \textbf{DeFi:} Hidden liquidation thresholds, private stop-loss triggers, dark limit orders
  \item \textbf{Wallet recovery:} Human-memorable recovery codes, on-chain wills, dead man's switches
  \item \textbf{Gaming \& NFTs:} On-chain puzzles, sealed-bid auctions, mystery box trait generation
  \item \textbf{Identity:} ENS recovery codes, one-time delegation codes, multi-code access control
\end{itemize}

The core problem: EVM has no memory-hard KDF (Argon2/scrypt) as a precompile. Keccak256 can be brute-forced at ${\sim}1$ns/guess, making low-entropy secrets (human phrases, small ranges) trivially crackable offline. \tlos{} addresses this with two complementary mechanisms: (1)~standard LWE verification ($n{=}384$, $\sigma{=}8$) that slows each guess to $10^5$--$10^6$/second on GPU~\cite{GPUFalcon23,GPUHybrid25}, and (2)~a planted ternary puzzle (Layer~4) that enforces a $2^{76}$ computational floor \emph{regardless of input entropy}. This means even a 6-digit PIN gains $2^{76}$ protection, not just the $10^6$ combinations an attacker would expect.

Traditional circuit obfuscation aims for \emph{permanent} security: given the obfuscated circuit $\obf(C)$, no efficient adversary can ever extract useful information beyond input-output behavior. The best theoretical constructions achieve indistinguishability obfuscation (iO) from LWE~\cite{JLS21,GP21,CLW25}, but with overhead exceeding $10^6\times$; far too expensive for on-chain deployment.

\subsection{Our Approach: Four-Layer Obfuscation}

We take a practical approach: \emph{resist known attack classes} through four complementary security layers.

\begin{center}
\framebox{\parbox{0.9\textwidth}{
\textbf{Four-Layer Defense-in-Depth:}

\begin{enumerate}
  \item \textbf{Layer 1 (Topology --- stops the reverse engineer):} Structural mixing defeats pattern-matching attacks through wire selection (non-pow2 distances, uniform usage, irregular layers). \emph{Security: heuristic, empirically validated.}
  
  \item \textbf{Layer 2 (LWE --- stops the cryptanalyst):} On-chain inner product computation defeats semantic attacks (RainbowTable). Control functions hidden via standard LWE ciphertexts with Gaussian noise ($\sigma{=}8$). \emph{Security: ${\sim}2^{112}$ PQ (confirmed by lattice estimator).}
  
  \item \textbf{Layer 3 (Wire Binding --- stops the hacker):} Full-rank linear hash binds wire values across gate evaluations, preventing mix-and-match attacks (see \S\ref{sec:wire-binding}). \emph{Security: algebraic binding via bijective map.}
  
  \item \textbf{Layer 4 (Puzzle --- stops the GPU miner):} Forces minimum $3^{48} \approx 2^{76}$ brute-force search space regardless of input entropy. Puzzle verification costs 1.26M gas. \emph{Security: computational (ternary LWE).}
\end{enumerate}

\textbf{Key mechanism:} Wrong-key decryption yields garbage; wire binding ensures consistent execution traces.
}}
\end{center}

\subsection{Key Insight: Wrong-Key-Gives-Garbage}

The RainbowTable attack is \emph{semantic}: it matches circuit behavior (truth tables of subcircuits) rather than structure. The attack proceeds by:

\begin{enumerate}
  \item Extracting subcircuits from the obfuscated circuit
  \item Evaluating each subcircuit on sample inputs to compute its truth table
  \item Matching the truth table against a pre-computed lookup table
\end{enumerate}

Topology-only defenses cannot block this attack because any structural transformation preserves the semantic behavior of reversible circuits.

\textbf{The LWE layer defeats step 2 via wrong-key garbage.} Control functions are hidden via standard LWE ciphertexts with Gaussian noise ($\sigma{=}8$) where the encryption key $s_{\mathsf{enc}} = H(\mathsf{secret})$ is derived from the \emph{correct} secret. An attacker with full bytecode can simulate circuit evaluation on any candidate input $x'$, but:
\begin{itemize}
  \item The derived evaluation key $s(x') = H(x')$ will be \emph{wrong} for $x' \neq \mathsf{secret}$
  \item Evaluating with the wrong key produces random/incorrect control function bits (garbage)
  \item Recovering the correct CFs without knowing the secret requires solving the LWE problem with $n{=}384$ and $\sigma{=}8$
\end{itemize}

\textbf{Important:} Attackers \emph{can} simulate the circuit offline; this is not a ``restricted oracle'' in the sense of blocking evaluation. The defense is that wrong-key evaluation yields \emph{meaningless} subcircuit semantics. The on-chain contract reinforces this by exposing only a 1-bit oracle (true/false), limiting information leakage per query.

\subsection{Contributions}

\begin{enumerate}
  \item \textbf{\tlos{} Framework:} A four-layer obfuscation framework for EVM combining topology-based structural mixing, on-chain LWE with Gaussian noise ($\sigma{=}8$) inner products, a full-rank wire binding layer, and a planted LWE puzzle layer. Our implementation uses $n{=}384$ LWE dimension and a $64{\times}64$ binding matrix, achieving 1.8M--6M gas (3--10\% of block) and 11 bytes/gate storage (seed-derived $\vec{a}$ vectors) with 9/9 resistance in our attack evaluation matrix.
  
  \item \textbf{Structural Mixing:} Wire selection algorithm defeating structural and statistical attacks through non-pow2 distances, uniform wire usage, and irregular layers. Security is heuristic and empirically validated.
  
  \item \textbf{Wrong-Key Garbage Property:} Attackers can simulate evaluation offline with any candidate input, but wrong keys yield garbage control function bits. The on-chain 1-bit oracle limits information leakage per query.
  
  \item \textbf{On-Chain LWE with Gaussian Noise:} Control functions hidden via standard LWE ciphertexts with Gaussian noise ($\sigma{=}8$) with full inner product computation on-chain. No hints or shortcuts; recovering control-function bits without the secret requires solving LWE.
  
  \item \textbf{Planted LWE Puzzle:} Layer 4 forces minimum $3^{48} \approx 2^{76}$ brute-force search space via a ternary LWE puzzle with planted solution. Puzzle verification costs 1.26M gas (3--12\% overhead). This protects low-entropy inputs from GPU brute-force attacks.
  
  \item \textbf{Post-Quantum Resistance:} Security of control-function hiding relies on the hardness of standard LWE with Gaussian noise. Our ${\sim}2^{112}$ PQ estimate for $n{=}384$ with $\sigma{=}8$ is confirmed by the lattice estimator (see Table~\ref{tab:lwe-security}).
  
  \item \textbf{Attack Evaluation:} Empirical validation against 14 attack implementations across 6 categories.
\end{enumerate}

\subsection{Scope and Limitations}

\textbf{What \tlos{} provides:}
\begin{itemize}
  \item Computational security based on hardness of standard LWE with Gaussian noise ($\sigma{=}8$) (confirmed by the lattice estimator; see Table~\ref{tab:lwe-security} for complexity estimates) plus empirical heuristics (topology layer)
  \item Attack resistance (9/9 in our evaluation matrix; not a universal security claim)
  \item Practical gas costs (1.8M--6M for $n{=}384$, 3--10\% of 60M block limit)
  \item Post-quantum resistance (${\sim}2^{112}$ security for $n{=}384$ with $\sigma{=}8$)
  \item Public evaluation: no secret keys required to evaluate the circuit on-chain
  \item Wrong-key garbage property: attackers can simulate offline but wrong keys yield garbage outputs
\end{itemize}

\textbf{Offline simulation:} An attacker with full bytecode can simulate circuit evaluation on any candidate input $x'$ offline. This is \emph{not} blocked. The security property is that wrong keys ($x' \neq \mathsf{secret}$) yield garbage control function bits, so the attacker learns nothing useful. Only the correct key produces meaningful evaluation.

\textbf{What \tlos{} does NOT provide:}
\begin{itemize}
  \item Permanent indistinguishability obfuscation (iO); we do not claim that obfuscations of equivalent circuits are indistinguishable
  \item Universal security against all possible attacks; we resist our 9-class taxonomy only
  \item Forward secrecy for long-lived secrets (expired secrets may be analyzed retroactively)
  \item Protection against protocol logic bugs, economic/incentive attacks, or EVM-level side channels
  \item Security after LWE compromise: if an adversary recovers all control function bits (e.g., by breaking the underlying LWE instances), the circuit becomes a fully specified reversible circuit that can be inverted gate-by-gate in linear time. The topology layer offers no post-compromise security; it only increases the cost of \emph{pre-compromise} structural and statistical attacks
\end{itemize}

\subsection{Related Work}

\textbf{Indistinguishability Obfuscation.} The breakthrough work of~\cite{GGH13} established iO from multilinear maps. Recent constructions achieve iO from LWE~\cite{JLS21,GP21,CLW25}. Diamond iO~\cite{SBP25} provides a practical construction but requires 100GB+ and is limited to ${\sim}8$K input bits. These provide provable security under standard assumptions but are not deployable on-chain.

\textbf{Compute-and-Compare Obfuscation.} Wichs and Zirdelis~\cite{WZ17} and Goyal, Koppula, and Waters~\cite{GKW17} achieve VBB security for compute-and-compare programs (predicates of the form $P(x) = [f(x) = s]$) under LWE. Our application of \cac{} to control function hiding is inspired by this work.

\textbf{Local Mixing.} Canetti et al.~\cite{CCMR24} explore obfuscation via local, functionality-preserving perturbations in reversible circuits. Our topology layer uses related ideas but focuses on attack-resistant construction rather than perturbation-based rerandomization.

\textbf{Smart Contract Privacy.} Existing approaches use ZK-SNARKs (e.g., Railgun, Aztec for private transfers), FHE with TEE (e.g., Zama's fhEVM), or pure TEE enclaves (e.g., Oasis Network). \tlos{} provides a new point in the design space: on-chain obfuscation without trusted hardware, FHE coprocessors, or external proving infrastructure.

%------------------------------------------------------------------------------
\section{Application Scope}
\label{sec:app-scope}
%------------------------------------------------------------------------------

\subsection{Deployment Constraints}

\tlos{} is designed for environments with the following constraints:

\begin{itemize}
  \item \textbf{On-chain only:} No off-chain computation or trusted servers available
  \item \textbf{No zk-SNARKs:} Proof systems unavailable, too complex, or undesirable
  \item \textbf{No private L2:} Must deploy on public L1 (Ethereum mainnet, L2 rollups)
  \item \textbf{Gas cost is acceptable:} At 0.03 gwei, 1.8M--6M gas $\approx$ \$0.05--\$0.20, negligible for most applications
\end{itemize}

Under these constraints, \tlos{} provides a practical mechanism to make secret verification more expensive on EVM. No memory-hard KDF (Argon2, scrypt, bcrypt) exists as an EVM precompile. Keccak256 can be brute-forced at ${\sim}10^9$ guesses/sec on GPU; \tlos{} with $n{=}384$ and Gaussian noise reduces this to ${\sim}10^5$--$10^6$ guesses/sec, a $10^3$--$10^4\times$ slowdown (see \S\ref{sec:gpu-attack}).

\subsection{Practical Use Cases}

\subsubsection{DeFi: Hidden Strategy Parameters}

\begin{itemize}
  \item \textbf{Private liquidation thresholds:} Users can hide their liquidation trigger prices inside a TLOS circuit. MEV bots cannot front-run liquidations if they don't know the threshold. The circuit checks if \texttt{(oracle\_price, user\_code)} satisfies secret conditions before triggering.
  
  \item \textbf{Hidden stop-loss / take-profit:} Trading vaults embed strategy parameters (price levels, exposure limits) in obfuscated circuits. Attackers cannot reverse-engineer the exact conditions that trigger position changes.
  
  \item \textbf{Dark limit orders:} Price bands and slippage tolerances are hidden. Even if bid/ask ranges are from a small domain (1000 discrete ticks), TLOS makes dictionary attacks prohibitively slow.
\end{itemize}

\subsubsection{Wallet Recovery \& Inheritance}

\begin{itemize}
  \item \textbf{Human-memorable recovery codes:} Smart wallets can use 6-word recovery phrases protected by TLOS. With keccak, a $10^6$-word dictionary is cracked in $<$1ms; with TLOS on GPU, the same search takes ${\sim}1$--$10$ seconds. \textbf{Caution:} This is insufficient for high-value wallets; use only for low-value recovery or combine with rate-limiting.
  
  \item \textbf{On-chain wills:} Family passphrases unlock inheritance. The distribution structure (who gets what percentage) is hidden inside the circuit. Multiple heirs can have different secrets encoded.
  
  \item \textbf{Dead man's switch:} Liveness criteria and claim codes are both obfuscated. Attackers cannot mimic the expected ``alive'' pattern because they don't know what's being checked.
\end{itemize}

\subsubsection{Gaming \& NFTs}

\begin{itemize}
  \item \textbf{On-chain puzzles:} Low-entropy riddle answers are protected from GPU brute-force. Honest human solvers compete fairly; automated mass-guessing becomes economically prohibitive.
  
  \item \textbf{Sealed-bid auctions:} Bids from small domains (0--10,000 price levels) cannot be dictionary-attacked. Each guess requires expensive TLOS evaluation.
  
  \item \textbf{Mystery box trait generation:} The algorithm mapping \texttt{(tokenId, entropy)} to traits is obfuscated. Minters cannot predict or steer for rare outcomes.
\end{itemize}

\subsubsection{Identity \& Access Control}

\begin{itemize}
  \item \textbf{ENS recovery:} High-value ENS names can be protected by human-memorable codes that would be trivially crackable with keccak.
  
  \item \textbf{One-time delegation codes:} Short numeric codes (6 digits) grant temporary access. TLOS makes $10^6$ guesses take hours instead of milliseconds.
  
  \item \textbf{Multi-code access:} OR of $N$ event codes with hidden structure; attackers don't know how many codes exist or their format.
\end{itemize}

\subsection{When NOT to Use TLOS}

\tlos{} is \emph{not} designed for:

\begin{itemize}
  \item \textbf{High-entropy secrets:} Random 256-bit keys are already secure with keccak256.
  \item \textbf{Long-term keys:} FHE decryption keys, signing keys, or secrets that must remain confidential for decades.
  \item \textbf{When alternatives exist:} If zk-SNARKs, private L2s, or off-chain KDFs are available and acceptable, they may be simpler.
\end{itemize}

For long-lived secrets, an adversary can analyze the circuit for arbitrarily long time. While our LWE construction with Gaussian noise provides computational security (${\sim}2^{112}$ PQ for $n{=}384$ with $\sigma{=}8$), we do not claim this is sufficient for secrets requiring decades of protection.

%------------------------------------------------------------------------------
\section{Preliminaries}
%------------------------------------------------------------------------------

\subsection{Learning With Errors}

\begin{definition}[\lwe{}~\cite{Regev05}]
For dimension $n$, modulus $q$, and error distribution $\chi$, the \lwe{}$_{n,q,\chi}$ problem is: given $(A, As + e \mod q)$ where $A \leftarrow \mathbb{Z}_q^{m \times n}$, $s \leftarrow \mathbb{Z}_q^n$, $e \leftarrow \chi^m$, distinguish from uniform $(A, u)$ where $u \leftarrow \mathbb{Z}_q^m$.
\end{definition}

\begin{theorem}[\lwe{} Hardness~\cite{Regev05,Pei09}]
For appropriate parameters, \lwe{} is as hard as worst-case lattice problems (e.g., GapSVP, SIVP) with polynomial approximation factors.
\end{theorem}

\lwe{} is believed quantum-resistant and forms the basis for post-quantum cryptography standards including ML-KEM~\cite{FIPS203}. Our deployed parameter ($n{=}384$, $q{=}65521$, $\sigma{=}8$) attains ${\sim}2^{112}$ post-quantum security according to the LWE Estimator~\cite{APS15}; see Table~\ref{tab:lwe-security}.

\subsection{Compute-and-Compare Obfuscation}

\begin{definition}[\cac{}~\cite{GKW17,WZ17}]
A \cac{} program $P_{f,t,m}$ is defined by a function $f$, a target value $t$, and a message $m$:
\[
P_{f,t,m}(x) = \begin{cases}
m & \text{if } f(x) = t \\
\perp & \text{otherwise}
\end{cases}
\]

A \cac{} obfuscator $\obf$ produces $\obf(P_{f,t,m})$ such that:
\begin{enumerate}
  \item \textbf{Correctness:} $\obf(P)(x) = P(x)$ for all $x$
  \item \textbf{Security:} No \ppt{} adversary can learn $m$ or $t$ except by finding $x$ such that $f(x) = t$
\end{enumerate}
\end{definition}

\begin{theorem}[\cac{} Security~\cite{WZ17}]
Under \lwe{} hardness, there exists a \cac{} obfuscator achieving VBB security for \cac{} programs.
\end{theorem}

We apply \cac{} to hide control functions: each gate's control function $c_f: \{0,1\}^2 \to \{0,1\}$ is encoded as a \cac{} program. The attacker cannot evaluate the gate without knowing the (encrypted) control function.

\subsection{Reversible Boolean Circuits}

\begin{definition}[Reversible Gate]
A reversible gate $g = (a, c_1, c_2, c_f)$ operates on $n$ wires where:
\begin{itemize}
  \item $a \in [n]$ is the active wire
  \item $c_1, c_2 \in [n] \setminus \{a\}$ are distinct control wires
  \item $c_f : \{0,1\}^2 \to \{0,1\}$ is the control function (one of 16 possible)
\end{itemize}
Gate evaluation: $\mathit{state}'[a] = \mathit{state}[a] \xorgate c_f(\mathit{state}[c_1], \mathit{state}[c_2])$
\end{definition}

\begin{proposition}
Every reversible gate is self-inverse: $g(g(s)) = s$ for all states $s$.
\end{proposition}

\begin{definition}[Circuit]
A reversible circuit $C = (g_1, \ldots, g_m)$ is a sequence of reversible gates evaluated sequentially.
\end{definition}

The self-inverse property enables commit-reveal protocols where the solver demonstrates knowledge of the secret without revealing it in the commit phase.

%------------------------------------------------------------------------------
\section{The \tlos{} Framework}
%------------------------------------------------------------------------------

\subsection{System Architecture}

\tlos{} consists of four layers, deployed as a single smart contract:

\begin{enumerate}
  \item \textbf{Topology Layer:} Structural mixing that defeats structural and statistical attacks through wire selection patterns. No cryptographic primitives; purely structural.
  
  \item \textbf{LWE Layer:} On-chain LWE inner-product computation with Gaussian noise ($\sigma{=}8$) hides control functions, defeating semantic attacks by preventing subcircuit evaluation.
  
  \item \textbf{Wire Binding Layer:} Full-rank $64{\times}64$ linear hash binds wire values across gates, preventing mix-and-match attacks. Updated every 128 gates for gas efficiency.
  
  \item \textbf{Planted Puzzle Layer:} Ternary LWE puzzle ($n{=}48$) forces $2^{76}$ minimum brute-force work regardless of input entropy. Verification costs 1.26M gas.
\end{enumerate}

\textbf{Deployment:} A single smart contract with:
\begin{itemize}
  \item Circuit data (gates encoded as bytes)
  \item Expected output hash (for verification)
  \item Expiry timestamp (after which the secret is no longer protected)
  \item Commit-reveal storage (for front-running protection)
\end{itemize}

No external infrastructure is required.

\subsection{Actor Model}

We describe the protocol through three actors:

\begin{itemize}
  \item \textbf{Alice (Publisher):} Deploys the obfuscated circuit with an embedded secret. Sets the expiry timestamp based on the application's requirements.
  
  \item \textbf{Bob (User):} Attempts to solve the circuit by finding the secret. Uses commit-reveal to prevent front-running.
  
  \item \textbf{Charlie (Attacker):} Attempts to reverse-engineer the circuit. Has full access to bytecode, circuit data, and can make arbitrary queries.
\end{itemize}

\subsection{Threat Model}
\label{sec:threat-model}

\textbf{Adversary capabilities (Charlie has full access to):}
\begin{itemize}
  \item Complete bytecode and circuit data (all on-chain data is public)
  \item All historical queries and responses from any user
  \item \textbf{1-bit oracle access:} Can call \texttt{check(x)} with any input $x$ and receive true/false
  \item Unbounded offline computation time
  \item Knowledge of the obfuscation scheme (Kerckhoffs's principle)
\end{itemize}

\textbf{Adversary constraints:}
\begin{itemize}
  \item \textbf{On-chain oracle interface:} Each on-chain query returns only 1 bit (true/false), limiting information leakage per query. The attacker cannot query intermediate wire states via the contract.
  \item \textbf{Input-dependent key derivation:} The decryption key $s = H(\mathsf{input} \| \mathsf{puzzleSolution})$ is derived from the input at evaluation time. This defeats white-box tracing attacks: an attacker tracing execution with wrong input $x'$ observes $\mathsf{diff} = b - \langle a, H(x') \rangle$, which equals $\langle a, s_{\mathsf{correct}} - H(x') \rangle + \mu \cdot (q/2)$. Since $s_{\mathsf{correct}} - H(x')$ is essentially random, the observed $\mathsf{diff}$ is uniformly distributed and reveals nothing about $\mu$. \emph{Traces are visible but useless without the correct input.}
  \item \textbf{Wrong-key garbage:} Attackers \emph{can} simulate evaluation offline with any candidate input $x'$. However, wrong keys yield garbage control function bits. The ciphertexts are encrypted under $s_{\mathsf{enc}} = H(\mathsf{secret})$; decrypting with $s(x') = H(x')$ for $x' \neq \mathsf{secret}$ produces random bits.
  \item \textbf{LWE hardness:} Recovering correct CF bits without knowing the secret requires solving the LWE problem with $n{=}384$ and Gaussian noise $\sigma{=}8$. The lattice estimator confirms ${\sim}2^{112}$ PQ security (Table~\ref{tab:lwe-security}).
  \item \textbf{Expiry:} After the timestamp, the secret may no longer be valuable (application-specific).
\end{itemize}

\textbf{Why structural attacks fail:}
\begin{itemize}
  \item \textbf{Point functions have no gadgets:} TLOS circuits compute $C(x) = 1$ iff $x = \mathsf{secret}$. There are no adders, comparators, or hash rounds---only a reversible permutation with one distinguished output. Standard gadget-recognition attacks do not apply.
  \item \textbf{Reversible gates $\neq$ standard logic:} Each gate computes $\mathit{state}[a] \mathrel{\oplus}= c_f(\mathit{state}[c_1], \mathit{state}[c_2])$. This is structurally different from AND/OR/XOR gates in conventional circuits.
  \item \textbf{Combined security:} Security relies on \emph{both} topology obfuscation (hiding $\mu$ from structural analysis) \emph{and} LWE with Gaussian noise (hiding $s$ given encrypted $\mu$). The $2^{112}$ estimate applies to cryptanalytic attacks on LWE \emph{assuming} $\mu$ is not predictable from circuit structure. If $\mu$ can be predicted for $n$ gates, the LWE layer provides no additional security.
\end{itemize}

\textbf{Composition rule:} For a point-function circuit on input space $\mathcal{X}$ with entropy $h$, the cost of finding a preimage is:
\[
\min\big(2^h,\ 2^{112},\ 2^{76}\big)
\]
where $2^h$ is brute-force over inputs, $2^{112}$ is LWE security, and $2^{76}$ is the puzzle's per-guess cost floor. Layers 1 (Topology) and 3 (Wire Binding) raise the bar against structural/mix-and-match \emph{shortcuts} but do not multiply the security level---they prevent attackers from bypassing the cryptographic layers.

\textbf{Out of scope:}
\begin{itemize}
  \item EVM-level side channels (gas timing, storage access patterns)
  \item Multi-instance attacks across related contracts
  \item Protocol logic bugs or economic attacks
  \item Attacks on the commit-reveal mechanism itself
\end{itemize}

\subsection{Protocol Flow}

\textbf{Deployment (Alice):}
\begin{enumerate}
  \item Generate circuit $C$ that computes $C(x) = 1$ iff $x = \mathit{secret}$
  \item Apply topology layer: wire selection with non-pow2 distances, uniform usage
  \item Apply LWE layer: encode control functions as LWE ciphertexts with Gaussian noise ($\sigma{=}8$)
  \item Deploy contract with circuit data (SSTORE2), expected output hash, and expiry timestamp
\end{enumerate}

\textbf{Solving (Bob):}
\begin{enumerate}
  \item Compute $H = \mathsf{hash}(\mathsf{sender} \| \mathsf{guess})$
  \item Call \texttt{commit(H)}
  \item Wait $k \geq 1$ blocks
  \item Call \texttt{reveal(guess)}
  \item If $C(\mathsf{guess}) = 1$, receive reward
\end{enumerate}

\textbf{Attack (Charlie):}
\begin{enumerate}
  \item Analyze circuit structure (topology layer blocks structural attacks)
  \item Attempt subcircuit evaluation (LWE layer blocks; CFs hidden by LWE ciphertexts)
  \item Resort to brute force ($2^{256}$ for 256-bit secrets; infeasible)
\end{enumerate}

%------------------------------------------------------------------------------
\section{The Topology Layer}
%------------------------------------------------------------------------------

The topology layer is a reversible circuit mixing structure designed to defeat structural and statistical attacks through wire selection, without cryptographic primitives.

\subsection{Design Principles}

\begin{enumerate}
  \item \textbf{Non-pow2 distances:} Control wires are selected at distances $d \notin \{1, 2, 4, 8, 16, \ldots\}$ from the active wire. This defeats butterfly/FFT pattern detection, which relies on power-of-2 distances.
  
  \item \textbf{Uniform wire usage:} Each wire is used as active/control with approximately equal frequency. This defeats chi-squared statistical attacks that look for non-uniform distributions.
  
  \item \textbf{Irregular layer sizes:} Layers have varying numbers of gates (e.g., 30--70 gates per layer for 256-wire circuits). This defeats regularity detection attacks.
  
  \item \textbf{64+ wires minimum:} Sufficient wire count defeats diagonal correlation attacks. With 64+ wires, Pearson correlation between input and output bits drops below 0.10.
\end{enumerate}

\subsection{Wire Selection Algorithm}

\textbf{Algorithm: Topology Wire Selection}

\textit{Input:} Wire count $n$, gate index $i$, wire usage counts $\mathsf{usage}[1..n]$

\begin{enumerate}
\item \textbf{Select active wire:} $a \gets \arg\min_{w} \mathsf{usage}[w]$ (prefer underused wires)

\item \textbf{Select control wires with non-pow2 distances:}
  \begin{itemize}
    \item $d_1 \gets$ random non-pow2 distance in $[3, n/2]$
    \item $d_2 \gets$ random non-pow2 distance in $[3, n/2]$, $d_2 \neq d_1$
    \item $c_1 \gets (a + d_1) \mod n$
    \item $c_2 \gets (a + d_2) \mod n$
  \end{itemize}

\item \textbf{Update usage:}
  \begin{itemize}
    \item $\mathsf{usage}[a] \gets \mathsf{usage}[a] + 2$ (active counts more)
    \item $\mathsf{usage}[c_1] \gets \mathsf{usage}[c_1] + 1$
    \item $\mathsf{usage}[c_2] \gets \mathsf{usage}[c_2] + 1$
  \end{itemize}

\item \textbf{Return} $(a, c_1, c_2)$
\end{enumerate}

\subsection{Topology Attack Resistance}

The topology layer provides empirical resistance against structural and statistical attacks in our evaluation:

\begin{table}[h]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Attack} & \textbf{Type} & \textbf{Defense} & \textbf{Mechanism} \\
\midrule
Compression & Structural & Topology & No redundant/identity gates \\
PatternMatch & Structural & Topology & Random CF cycling \\
Structural (Butterfly) & Structural & Topology & Non-pow2 distances \\
Statistical (Chi-squared) & Statistical & Topology & Uniform wire usage \\
DiagonalCorrelation & Statistical & Topology & 64+ wires, irregular layers \\
\bottomrule
\end{tabular}
\caption{Topology layer resists structural and statistical attacks in our evaluation. Success should be read as ``no break found in our test suite,'' not ``provably secure.''}
\end{table}

\textbf{Key insight:} Unlike butterfly or derangement topologies that only rearrange gates, the topology layer has anti-attack properties \emph{built into wire selection}. The wire selection algorithm is designed specifically to resist known attack heuristics. \textbf{Important:} This is a closed-world evaluation against our implemented attacks. We cannot rule out future attacks that exploit structural patterns we have not anticipated. The topology layer should be viewed as raising the bar for structural analysis, not providing formal security guarantees.

%------------------------------------------------------------------------------
\section{The LWE Layer}
%------------------------------------------------------------------------------

\subsection{The RainbowTable Problem}

The RainbowTable attack is \emph{semantic}: it matches circuit behavior (truth tables of subcircuits) rather than structure. For reversible circuits, topology-only methods cannot defeat this attack because the functional behavior is preserved under any structural transformation.

\textbf{Attack procedure:}
\begin{enumerate}
  \item \textbf{Extract subcircuit:} Identify a subsequence of gates $g_i, \ldots, g_j$
  \item \textbf{Evaluate subcircuit:} Compute truth table by running the subsequence on all possible inputs
  \item \textbf{Match against table:} Compare truth table against pre-computed lookup table of known functions
\end{enumerate}

If a match is found, the attacker learns the semantic function computed by that subcircuit, potentially revealing the embedded secret or simplifying further analysis.

\subsection{How On-Chain LWE Blocks RainbowTable}

The wrong-key-gives-garbage property is the primary defense: attackers can simulate offline with any input, but wrong keys yield meaningless control function bits. The on-chain interface provides only a 1-bit full-circuit oracle. Standard LWE with Gaussian noise ($\sigma{=}8$) provides computational hardness.

\begin{center}
\fbox{\parbox{0.9\textwidth}{
\textbf{On-Chain Inner Product:} Each gate's control function is encoded as an LWE ciphertext $(a, b)$ where $b = \langle a, s \rangle + e + \mathsf{bit} \cdot q/2 \pmod q$ with Gaussian error $e \sim \mathcal{N}(0, \sigma^2)$ and $\sigma{=}8$. The secret $s = H(\mathsf{input})$ is derived from the circuit input at evaluation time. The contract computes the inner product on-chain:

\smallskip
\texttt{s = keccak256(input) expanded to n u16 elements mod q}\\
\texttt{innerProd = sum(a[i] * s[i]) mod q}\\
\texttt{diff = (b - innerProd) mod q}\\
\texttt{cfBit = (diff > q/4) \&\& (diff < 3*q/4)}
\smallskip

\textbf{No hints stored:} Unlike compact formats that store $(b, \mathsf{hint})$ pairs (which allow offline CF recovery), \tlos{} stores full $(a, b)$ ciphertexts. Recovering CFs without the secret requires solving the LWE problem with $n{=}384$ and $\sigma{=}8$.
}}
\end{center}

\begin{proposition}[LWE Hides Subcircuit Semantics]
Assuming hardness of the LWE problem with $n{=}384$ and Gaussian noise $\sigma{=}8$, no \ppt{} adversary can recover the \emph{true semantic behavior} (correct control function bits or truth tables) of a proper subcircuit without knowing the secret.
\end{proposition}

\begin{proof}[Proof sketch]
Let $C = (g_1, \ldots, g_m)$ be the circuit with control functions encoded as LWE ciphertexts with Gaussian noise under key $s_{\mathsf{enc}} = H(\mathsf{secret})$. For any proper subsequence $S = (g_i, \ldots, g_j)$:

An attacker \emph{can} run $S$ with any guessed input $x'$, deriving $s(x') = H(x')$. However, for $x' \neq \mathsf{secret}$, decrypting the control function ciphertexts with the wrong key $s(x')$ yields random bits, not the true control function values.

Recovering the correct CF bits from $(a, b)$ without knowing $s_{\mathsf{enc}}$ requires solving the LWE problem, which is hard under standard lattice assumptions.

Therefore, while adversaries can \emph{execute} subcircuits, they cannot recover meaningful semantics without the secret (or solving LWE).
\end{proof}

\begin{remark}
This proposition follows from the LWE assumption~\cite{Regev05}. The lattice estimator confirms ${\sim}2^{112}$ PQ security for our parameters ($n{=}384$, $\sigma{=}8$).
\end{remark}

\subsection{Control Function Encoding}

Each gate's control function $c_f: \{0,1\}^2 \to \{0,1\}$ (one of 16 possible) is represented as 4 LWE ciphertexts with Gaussian noise, one for each truth table entry: $c_f \mapsto (\mathsf{ct}_{00}, \mathsf{ct}_{01}, \mathsf{ct}_{10}, \mathsf{ct}_{11})$.

\textbf{LWE Parameters:}
\begin{itemize}
  \item Modulus: $q = 65521$ (largest 16-bit prime)
  \item Dimension: $n = 384$
  \item Sample count: $m = 256$--$2560$ (4 ciphertexts $\times$ 64--640 gates)
  \item Gaussian noise: $\sigma = 8$
\end{itemize}

\textbf{Gaussian noise for standard LWE security:} Encryption is $b = \langle a, s \rangle + e + \mu \cdot (q/2) \mod q$ where $\mu \in \{0,1\}$ is the control-function bit and $e \sim \mathcal{N}(0, \sigma^2)$ with $\sigma{=}8$. Decryption checks if $(b - \langle a,s \rangle) \mod q$ falls in $(q/4, 3q/4)$. With $\sigma{=}8$, decoding errors are negligible (error magnitude $\ll q/4$). This provides standard LWE security with ${\sim}2^{112}$ PQ hardness confirmed by the lattice estimator.

\textbf{Storage per gate (seed-derived $\vec{a}$):} With seed-derived $\vec{a}$ vectors, we store only $b$ values: 3 bytes for wire indices + 8 bytes for 4 $b$ values = \textbf{11 bytes/gate} regardless of $n$. Compare to storing full ciphertexts:
\begin{itemize}
  \item $n{=}384$ (seed-derived): \textbf{11 bytes/gate}, 7 KB total (640 gates)
\end{itemize}

\textbf{On-chain evaluation:}
\begin{enumerate}
  \item Load wire state from input
  \item Derive secret $s = H(\mathsf{input})$ expanded to $n$ elements
  \item For each gate: load $(a, b)$ ciphertext, compute inner product, extract CF bit, XOR with active wire
  \item Compare final state hash with expected output
\end{enumerate}

%------------------------------------------------------------------------------
\section{Security Analysis}
%------------------------------------------------------------------------------

\subsection{Four-Layer Security Model}

\tlos{} provides security through four complementary layers:

\begin{enumerate}
  \item \textbf{Topology layer (heuristic):} Resists structural and statistical attacks in our evaluation through wire selection patterns that break known attack heuristics. Security is \emph{empirical} (no successful breaks found in testing), validated against our attack suite but not formally proven. Success should be interpreted as ``no break found,'' not ``provably secure.''
  
  \item \textbf{LWE layer (computational):} Resists semantic attacks by hiding control functions via LWE ciphertexts with Gaussian noise ($\sigma{=}8$) and on-chain inner products. Security is based on standard LWE hardness with ${\sim}2^{112}$ PQ security (see Table~\ref{tab:lwe-security} and \S\ref{sec:lwe-hardness}).
  
  \item \textbf{Wire binding layer (algebraic):} Binds wire values across gates via full-rank linear hash, preventing mix-and-match attacks. Security is \emph{algebraic binding}, not cryptographic hiding.
  
  \item \textbf{Planted LWE puzzle (computational):} Forces minimum $3^{48} \approx 2^{76}$ brute-force search space regardless of input entropy. Security is \emph{computational}, based on ternary LWE hardness (see \S\ref{sec:puzzle}).
\end{enumerate}

\textbf{Wrong-key garbage property:} Attackers can simulate offline but wrong keys yield garbage. The on-chain contract exposes only 1-bit output, limiting information per query.

\subsection{LWE Security Estimates}

\textbf{Uniform-Secret LWE with Gaussian Noise.} A key property of \tlos{} is that the LWE secret $s_{\mathsf{enc}} = H(\mathsf{secret})$ is \emph{uniform} over $\mathbb{Z}_q^n$, not a small-coefficient secret as in some LWE variants. This arises naturally from expanding a cryptographic hash output to $n$ elements modulo $q$. The uniform-secret variant is at least as hard as standard LWE. With Gaussian noise $\sigma{=}8$, our construction inherits the well-studied security properties of standard LWE.

Table~\ref{tab:lwe-security} presents security estimates for our LWE construction with $n{=}384$ and Gaussian noise $\sigma{=}8$, confirmed by the lattice estimator. These estimates use BKZ lattice reduction with the ``Core-SVP'' cost model.

\begin{table}[h]
\centering
\begin{tabular}{@{}lccccl@{}}
\toprule
\textbf{Dimension $n$} & \textbf{$\sigma$} & \textbf{Classical} & \textbf{Quantum} & \textbf{Gas} & \textbf{Notes} \\
\midrule
\textbf{$n{=}384$} & \textbf{8} & \textbf{${\sim}220$-bit} & \textbf{${\sim}112$-bit} & \textbf{1.8M--6M} & \textbf{Deployed parameter (production use)} \\
\bottomrule
\end{tabular}
\caption{LWE security estimates ($q{=}65521$, Gaussian noise $\sigma{=}8$). Estimates from the lattice estimator~\cite{APS15} confirm ${\sim}2^{112}$ PQ security. Gas costs: 64 gates = 1.8M, 128 gates = 2M, 256 gates = 3M, 640 gates = 6M.}
\label{tab:lwe-security}
\end{table}

\textbf{Standard LWE security:} With Gaussian noise $\sigma{=}8$, our construction uses standard LWE and inherits its well-studied security properties. The lattice estimator confirms ${\sim}2^{112}$ post-quantum security for $n{=}384$. We validated these estimates via direct lattice attacks using fpylll/BKZ; see \S\ref{sec:attack-validation}.

\subsection{LWE Hardness Analysis}
\label{sec:lwe-hardness}

Our construction uses \emph{standard LWE with Gaussian noise}~\cite{Regev05}:

\begin{definition}[LWE with Gaussian Noise]
\label{def:lwe}
The problem LWE$(n, q, \sigma, m)$ is: given $m$ samples $(a_i, b_i)$ where $a_i \leftarrow \mathbb{Z}_q^n$ is uniform, $s \leftarrow \mathbb{Z}_q^n$ is a \emph{uniform} secret, and
\[
b_i = \langle a_i, s \rangle + e_i + \mu_i \cdot (q/2) \mod q \quad \text{where } e_i \sim \mathcal{N}(0, \sigma^2), \mu_i \in \{0,1\}
\]
recover $s$ or any $\mu_i$ with non-negligible probability. The $\mu_i$ values are the hidden payload (control function bits in our application).
\end{definition}

\begin{remark}[Standard LWE Security]
\label{rem:isomorphism}
With Gaussian noise $\sigma{=}8$, our construction inherits the well-studied security properties of standard LWE~\cite{Regev05}. The lattice estimator confirms ${\sim}2^{112}$ post-quantum security for $n{=}384$, $q{=}65521$, and $\sigma{=}8$. This provides a formal security reduction to worst-case lattice problems.
\end{remark}

\noindent Standard LWE with Gaussian noise provides strong security guarantees. We analyzed potential attack classes:

\textbf{Attack 1: Naive brute-force on all $\mu$.} An attacker could try all $2^m$ combinations of $\mu$ bits, checking consistency for each. For $m = 2560$ ciphertexts, this costs $2^{2560}$, completely infeasible. However, smarter attacks (Attack 5) reduce this to $2^n$.

\textbf{Attack 2: Lattice embedding.} Standard BDD/uSVP attacks embed $(s, e)$ as a short vector in a lattice. With Gaussian noise $\sigma{=}8$, the error norm is approximately $\|e\| \approx \sqrt{m} \cdot \sigma \approx 405$ for $m{=}2560$. The Gaussian heuristic for $n{=}384$ is approximately 179, so the error is ${\sim}2.3\times$ larger than the heuristic threshold. BDD attacks are infeasible. We verified this empirically: BKZ-50 on small instances failed to recover $s$.

\textbf{Attack 3: Subset-sum / ISD.} View as finding $\mu \in \{0,1\}^m$ such that $b - e - \mu \cdot (q/2) = As$ is consistent. With unknown Gaussian noise, this is harder than standard subset-sum. For $m = 2560$, $n = 384$, ISD attacks are infeasible.

\textbf{Attack 4: Statistical distinguishing.} Observe that $b_i \mod (q/2) = \langle a_i, s \rangle \mod (q/2)$ regardless of $\mu_i$. For uniform $s \in \mathbb{Z}_q^n$, the distribution of $\langle a_i, s \rangle \mod (q/2)$ is statistically close to uniform over $\mathbb{Z}_{q/2}$. No distinguishing advantage.

\textbf{Attack 5: Algebraic attacks on subsets.} If an attacker could guess some $\mu_i$ values, they could set up partial linear equations. However, with 2560 unknowns and only 384-dimensional secret, even correct guesses yield noisy equations due to the Gaussian error; still $2^{384}$ combinations to try.

\textbf{Empirical Validation.} We implemented 9 attack classes in \texttt{scripts/tlos\_attack.py}:

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{5cm}@{}}
\toprule
\textbf{Attack Class} & \textbf{Result} & \textbf{Details} \\
\midrule
Naive brute-force & FAIL & $2^{2560}$ (all $\mu$); infeasible \\
Statistical distinguishing & FAIL & $b$ uniform ($\chi^2 < 100$), no leakage \\
Lattice BDD/uSVP & FAIL & Error norm $405 >$ Gaussian heuristic $179$ \\
Linear algebra & FAIL & Gaussian noise prevents exact solution \\
Subset guessing & FAIL & Still requires $2^n$ guesses per subset \\
Hybrid (guess $k$ bits) & FAIL & Must guess all $n$ bits; cost remains $2^n$ \\
Meet-in-the-middle & FAIL & Not applicable: $s$ shared across all equations \\
Actual BKZ-50 reduction & FAIL & Finds only trivial short vectors \\
Gaussian noise exploit & FAIL & Noise prevents algebraic attacks \\
\bottomrule
\end{tabular}
\caption{Summary of 9 attack classes tested against LWE construction with Gaussian noise. All attacks fail.}
\end{table}

\textbf{Long-Running Exhaustive Validation.} We ran multi-hour exhaustive attacks on two servers to empirically measure attack scaling:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
$n$ & Rate (ops/s) & Full $2^n$ time & Extrapolated $n{=}128$ \\
\midrule
16 & 1,500 & 44 seconds & N/A \\
18 & 1,300 & 3.4 minutes & N/A \\
20 & 1,100 & 16 minutes & N/A \\
22 & 960 & 1.2 hours & N/A \\
24 & 820 & 5.7 hours & N/A \\
128 & (extrapolated) & N/A & $10^{28}$ years \\
\bottomrule
\end{tabular}
\caption{Exhaustive attack scaling (subset guessing). Here $n$ is the number of $\mu$ bits guessed per attempt. At ${\sim}1000$ ops/s, breaking $n{=}128$ requires $10^{28}$ years.}
\end{table}

\textbf{Parallelization.} The attack parallelizes trivially (each machine tries different $\mu$ subsets). However, even with $10^9$ parallel machines (all of Google's servers), $n{=}128$ still requires $10^{19}$ years. With $10^{18}$ machines (every atom a computer): $10^{10}$ years.

\begin{center}
\framebox{\parbox{0.9\textwidth}{
\textbf{Security Summary:} We tested 9 attack classes; all fail. Exhaustive search scales as $2^n$ with no shortcuts. Parallelization helps linearly but cannot overcome the exponential barrier. The ${\sim}2^{112}$ PQ security estimate is confirmed by the lattice estimator for $n{=}384$ with Gaussian noise $\sigma{=}8$.
}}
\end{center}

\subsection{Security Properties of Gaussian Noise LWE}
\label{sec:lwe-security-properties}

Our construction uses standard LWE with Gaussian noise $\sigma{=}8$, providing well-studied security properties.

\textbf{What Gaussian noise provides:}
\begin{enumerate}
  \item \textbf{Formal security reduction:} Standard LWE with Gaussian noise has a formal reduction to worst-case lattice problems (GapSVP, SIVP)~\cite{Regev05}.
  
  \item \textbf{Well-studied parameters:} Our choice of $n{=}384$, $q{=}65521$, and $\sigma{=}8$ is analyzed by the lattice estimator, confirming ${\sim}2^{112}$ post-quantum security.
  
  \item \textbf{Resistance to algebraic attacks:} Gaussian noise prevents exact algebraic solutions; attackers cannot set up perfect linear constraints.
\end{enumerate}

\textbf{Why security holds:}
\begin{enumerate}
  \item \textbf{Secret is unknown:} The adversary does \emph{not} know $s = H(\mathsf{secret})$. Recovering $\mu_i$ requires either knowing $s$ or solving LWE.
  
  \item \textbf{Gaussian noise:} The error term $e \sim \mathcal{N}(0, \sigma^2)$ prevents exact algebraic solutions and provides standard LWE security guarantees.
  
  \item \textbf{Lattice estimator confirmation:} The lattice estimator confirms ${\sim}2^{112}$ PQ security for our parameters.
\end{enumerate}

\textbf{Potential attacks (standard LWE analysis):}
\begin{itemize}
  \item \textbf{BDD/uSVP attacks:} Standard lattice attacks with complexity confirmed by the lattice estimator.
  
  \item \textbf{Multi-instance attacks:} If an adversary has access to multiple circuits encrypted under \emph{related} secrets, cross-circuit attacks may be possible. Our threat model assumes independent secrets.
\end{itemize}

\textbf{Call for independent analysis:} We encourage the cryptographic community to verify our security estimates. Our attack suite is available at \texttt{scripts/tlos\_attack.py}.

\subsection{Security Definitions}

\begin{definition}[Extraction Resistance]
An obfuscator $\obf$ is $(t, \varepsilon)$-extraction resistant if for all adversaries $\adv$ running in time $t$:
\[
\Pr[\adv(\obf(C)) \text{ outputs exploitable information about } C] \leq \varepsilon
\]
\end{definition}

\begin{definition}[Control-Function Hiding (Informal)]
\label{def:cf-hiding}
Let $\mathsf{Enc}_s(\mu) = (a, \langle a, s \rangle + \mu \cdot (q/2) \mod q)$ be our encoding scheme where $a \leftarrow \mathbb{Z}_q^n$ is uniform, $s \in \mathbb{Z}_q^n$ is the secret, and $\mu \in \{0,1\}$ is the control-function bit.

We say the encoding provides \emph{control-function hiding} if, for uniform $s$ unknown to the adversary:
\[
\Pr[\adv((a_1, b_1), \ldots, (a_m, b_m)) \text{ recovers any } \mu_i] \leq \mathsf{negl}(\lambda)
\]
where the probability is over the choice of $a_i$ and the adversary's coins.
\end{definition}

\begin{remark}[Relation to Standard LWE]
\label{rem:standard-lwe}
Since our construction uses independent Gaussian noise with $\sigma{=}8$, Definition~\ref{def:cf-hiding} is an instance of the standard LWE decision problem. The security of the control functions reduces to the hardness of worst-case lattice problems (e.g., GapSVP, SIVP) via the standard reductions established by Regev~\cite{Regev05} and Peikert~\cite{Pei09}.
\end{remark}

\begin{definition}[LWE Control Function Security]
\label{def:lwe-cf-security}
Control function encoding is secure if no \ppt{} adversary can recover control function bits from the ciphertexts with non-negligible advantage, assuming the hardness of LWE (Definition~\ref{def:lwe}).
\end{definition}

\subsection{Assumptions}

\begin{assumption}[LWE Hardness]
\label{asm:lwe}
The Learning With Errors problem with parameters $(n{=}384, q{=}65521, \sigma{=}8, m{=}2560)$ is computationally hard.

\emph{Justification:} These parameters yield an estimated hardness of ${\sim}2^{112}$ bits against known lattice attacks (primal/dual uSVP) according to the Lattice Estimator~\cite{APS15}. The error norm is approximately $2.3\times$ larger than the Gaussian heuristic of the dual lattice, rendering BDD attacks infeasible.
\end{assumption}

\begin{assumption}[Topology Empirical Security]
\label{asm:topology}
The topology layer's wire selection algorithm resists the structural and statistical attacks in our evaluation matrix.

\emph{Justification:} This is validated empirically via testing (no successful breaks found in 1000+ trials). While we rely on LWE for semantic security, the topology layer forces the adversary to perform lattice reduction rather than exploiting cheap structural shortcuts.
\end{assumption}

\subsection{Main Theorem}

\begin{theorem}[\tlos{} Attack Resistance]
\label{thm:main}
Under Assumption~\ref{asm:lwe} (LWE hardness), Assumption~\ref{asm:topology} (topology empirical security), and the wrong-key-gives-garbage property (1-bit on-chain oracle with no subcircuit access), \tlos{} achieves extraction resistance against our 9-class attack matrix.
\end{theorem}

\begin{proof}
We consider each attack class:

\textbf{Structural attacks (3/6):} Compression, PatternMatch, and Structural (Butterfly) attacks rely on detecting patterns in wire selection. The topology layer uses non-pow2 distances and random CF cycling, which \emph{no known attack in our suite successfully exploits}. \emph{Empirically validated} (Assumption~\ref{asm:topology}), but we cannot prove that more sophisticated structural attacks do not exist.

\textbf{Statistical attacks:} Statistical (Chi-squared) and DiagonalCorrelation attacks rely on non-uniform wire usage and input-output correlation. The topology layer enforces uniform wire usage and uses 64+ wires with irregular layers, which \emph{our implemented attacks fail to exploit}. \emph{Empirically validated} (Assumption~\ref{asm:topology}) against our test distributions.

\textbf{Semantic attacks:} RainbowTable requires subcircuit evaluation. The LWE layer hides control functions via ciphertexts with on-chain inner products. Recovering CFs requires solving LWE (Assumption~\ref{asm:lwe}).

Therefore, no attack in our 9-class evaluation matrix successfully extracts secrets under the stated assumptions. \emph{This should be read as ``no break found in our test suite,'' not ``secure against all possible attacks.'' We cannot rule out future attack vectors that exploit structural or statistical properties we have not tested.}
\end{proof}

\subsection{Post-Quantum Security}

\begin{proposition}[\tlos{} Post-Quantum Security]
\tlos{} is post-quantum secure assuming the underlying LWE problem is quantum-resistant.
\end{proposition}

\begin{proof}
The topology layer uses no cryptographic primitives; it is purely structural and unaffected by quantum computers.

The cryptographic security of the control functions relies entirely on LWE$(n{=}384, q{=}65521, \sigma{=}8)$. Since LWE is widely believed to be secure against quantum computers and forms the basis of NIST post-quantum standards (e.g., ML-KEM~\cite{FIPS203}), our construction inherits this resistance. Specifically, for $n{=}384$ and $\sigma{=}8$, the best known quantum attacks (Grover-accelerated lattice sieving) require ${\sim}2^{112}$ operations.
\end{proof}



\subsection{Oracle Model Considerations}

In the oracle model, the attacker can query the circuit on chosen inputs.

\begin{observation}
For predicate circuits with $n$-bit inputs and 1-bit output, brute-force requires $2^n$ queries.
\end{observation}

For honeypots with 256-bit secrets, brute-force is infeasible. The binary output limits information leakage: each query reveals only one bit, and the output is independent of all inputs except the secret.

\begin{observation}[Oracle Attack Cost]
For predicates $P(x) = [f(x) = s]$ where $s$ has min-entropy $k$ bits, classical oracle-based search requires $\Theta(2^k)$ queries. Quantum search (Grover) reduces this to $\Theta(2^{k/2})$ queries.
\end{observation}

For honeypots with 256-bit secrets, even quantum brute-force is infeasible ($2^{128}$ queries).

\subsection{Oracle Leakage Analysis}
\label{sec:oracle-leakage}

We now provide a more formal analysis of information leakage through the 1-bit on-chain oracle interface.

\textbf{Oracle interface:} The on-chain contract exposes a single function \texttt{check(x)} that returns 1 if $x = \mathsf{secret}$ and 0 otherwise. Let $\mathcal{O}$ denote this oracle.

\textbf{Information-theoretic bound:} For a secret $s$ with min-entropy $k$ bits, each oracle query $\mathcal{O}(x)$ reveals at most 1 bit of information about $s$. In the worst case, an adaptive adversary making $q$ queries learns at most $q$ bits.

\textbf{Shannon entropy analysis:} Let $H(S)$ denote the entropy of the secret distribution. After $q$ queries $\{x_1, \ldots, x_q\}$ with responses $\{r_1, \ldots, r_q\}$, the conditional entropy satisfies:
\[
H(S \mid r_1, \ldots, r_q) \geq H(S) - q
\]
For uniformly random $k$-bit secrets, $H(S) = k$, so the adversary must make at least $k$ queries to fully determine $s$ (information-theoretically).

\textbf{Practical leakage:} For point functions $P(x) = [x = s]$ where $s$ is uniformly distributed over a domain of size $2^k$:
\begin{itemize}
  \item Each \emph{negative} response ($\mathcal{O}(x_i) = 0$) rules out exactly one candidate: $s \neq x_i$
  \item Expected queries to find $s$ via random search: $\Theta(2^k)$
  \item Best-case adaptive strategy (if structure is known): still $\Theta(2^k)$ for uniformly random $s$
\end{itemize}

\textbf{Comparison with multi-bit oracles:} If the oracle returned intermediate wire states or multi-bit outputs, leakage would be dramatically higher. For example, an oracle returning the Hamming distance $|x \oplus s|$ would enable binary search, reducing attack cost from $\Theta(2^k)$ to $\Theta(k)$ queries.

\textbf{Side-channel considerations (out of scope):} Our analysis assumes the oracle leaks \emph{only} the 1-bit output. In practice, EVM-level side channels (gas usage, storage access patterns, timing) may leak additional information. Mitigating these is outside the scope of \tlos{} and would require:
\begin{itemize}
  \item Constant-time/constant-gas implementations (challenging in EVM)
  \item Oblivious RAM-style storage access (prohibitively expensive)
  \item Differential privacy techniques (not applicable to deterministic predicates)
\end{itemize}

\textbf{Open problem:} A fully formal leakage analysis would model the adversary's knowledge as a probability distribution over the secret space and quantify how oracle responses update this distribution. For uniform secrets and memoryless oracles, the 1-bit bound is tight. For structured secrets or stateful adversaries (e.g., learning the circuit structure over many queries), tighter bounds may be possible. We leave this to future work and welcome formal analysis by the cryptographic community.

%------------------------------------------------------------------------------
\section{The Planted LWE Puzzle (Layer 4)}
\label{sec:puzzle}
%------------------------------------------------------------------------------

\subsection{The GPU Brute-Force Problem}

Layers 1--3 provide strong protection against structural, semantic, and mix-and-match attacks. However, they cannot prevent an adversary from brute-forcing over the input space. If the secret has low entropy (e.g., $2^{30}$ possibilities), a GPU evaluating LWE inner products at $10^6$ guesses/sec can crack it in ${\sim}17$ minutes.

\textbf{Benchmark (NVIDIA GH200):} Our GPU implementation achieves 22--86M TLOS circuit evaluations per second depending on gate count. For a $2^{30}$ input space, exhaustive search completes in 12--50 seconds.

\subsection{Planted LWE Construction}

Layer 4 forces a minimum search space by requiring solvers to find a ternary secret $s \in \{-1,0,1\}^n$ satisfying an LWE-like constraint. For each input $x$:

\begin{enumerate}
\item Derive puzzle seed: $\mathsf{seed} = H(\mathsf{DOMAIN} \| x)$
\item Derive planted secret: $s^* \in \{-1,0,1\}^n$ from $\mathsf{seed}$
\item Derive matrix: $A \in \mathbb{Z}_q^{m \times n}$ row-by-row from $\mathsf{seed}$
\item Derive error: $e \in \{-2,-1,0,1,2\}^m$ from $\mathsf{seed}$
\item Compute target: $b = As^* + e \mod q$
\end{enumerate}

The verifier checks: $\|As - b\|^2 < \tau$ for the candidate solution $s$.

\begin{definition}[Planted Ternary LWE Puzzle]
For parameters $(n, m, q, \tau)$, given $(A, b)$ derived from input $x$, find $s \in \{-1,0,1\}^n$ such that $\|As - b \mod q\|^2 < \tau$, where the norm uses centered representatives in $(-q/2, q/2]$.
\end{definition}

\textbf{Correctness:} The planted secret $s^*$ always satisfies the constraint since $As^* - b = -e$ and $\|e\|^2 \leq m \cdot 4 = 288 < \tau = 300$.

\textbf{Uniqueness:} For random $s \neq s^*$, the residual $As - b$ is essentially uniform over $\mathbb{Z}_q^m$. The probability that a random $s$ satisfies $\|As - b\|^2 < \tau$ is approximately $(5/q)^m \approx 10^{-188}$, ensuring the planted solution is essentially unique.

\subsection{Parameters}

\begin{table}[h]
\centering
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Secret dimension $n$ & 48 \\
Samples $m$ & 72 \\
Modulus $q$ & 2039 \\
Secret distribution & Ternary $\{-1,0,1\}$ \\
Error distribution & Uniform $\{-2,-1,0,1,2\}$ \\
Threshold $\tau$ & 300 \\
Search space & $3^{48} \approx 2^{76}$ \\
Verification gas & 1.26M \\
\bottomrule
\end{tabular}
\caption{Planted LWE puzzle parameters for Layer 4.}
\label{tab:puzzle-params}
\end{table}

\subsection{Security Analysis}

\textbf{Brute-force resistance:} The search space is $3^{48} \approx 2^{76}$. At 1B guesses/sec (NVIDIA GH200 FP16, worst-case attacker), exhaustive search requires:
\begin{itemize}
\item 1 GPU: ${\sim}2.5$ million years
\item 100 GPUs: ${\sim}25,000$ years  
\item 10,000 GPUs: ${\sim}250$ years
\end{itemize}

\textbf{FP16 precision:} Attackers may use half-precision (FP16) arithmetic for faster GPU computation. We tested 107 billion guesses comparing FP32 vs FP16: both produced zero false positives, and both correctly identified planted solutions. FP16 is safe for attackers, so our worst-case 1B/sec figure is valid.

\textbf{Meet-in-the-middle:} MITM on $3^{48} = 3^{24} \times 3^{24}$ requires storing ${\sim}2.8 \times 10^{11}$ partial results (${\sim}9$ TB). This is feasible for well-resourced attackers with distributed storage, so we do not rely on MITM infeasibility---security comes from the $3^{48}$ search space and LWE hardness.

\textbf{Power efficiency:} At 1B guesses/sec and ${\sim}700$W, exhausting the puzzle space costs ${\sim}\$1.5$ billion in electricity alone (${\sim}2.5$ million GPU-years at \$0.10/kWh).

\textbf{Lattice attacks:} Using the lattice-estimator~\cite{LatticeEstimator}, we verified the puzzle parameters:
\begin{itemize}
\item \textbf{Coded-BKW:} $2^{32.8}$ operations (best attack)
\item \textbf{uSVP/BDD:} $2^{38}$--$2^{40}$ operations
\item \textbf{Dual-hybrid:} $2^{40}$ operations
\end{itemize}
The puzzle is \emph{intentionally weak} against lattice attacks (${\sim}2^{33}$). Its purpose is not to resist cryptanalysis but to \emph{force minimum computational work per guess}---the $3^{48}$ ternary search space ensures attackers cannot shortcut via low-entropy inputs. Even with lattice attacks, exhausting $3^{48}$ candidates at $2^{33}$ work each gives total cost $2^{76+33} = 2^{109}$.

\textbf{False positives:} The probability of a random ternary vector satisfying the threshold is $< 10^{-180}$, ensuring essentially unique solutions.

\subsection{Integration with TLOS}

The puzzle solution $s$ is combined with the input $x$ to derive the LWE decryption key:
\[
\mathsf{key} = H(x \| H(s))
\]

This provides \emph{double binding}: an attacker must both solve the planted LWE puzzle AND possess the correct input $x$. Neither alone is sufficient.

\textbf{Gas overhead:} Puzzle verification adds 1.26M gas to the base TLOS evaluation (1.8M--6M for $n{=}384$), a modest increase.

%------------------------------------------------------------------------------
\section{Gas Costs and Deployment}
%------------------------------------------------------------------------------

\subsection{Gas Estimates}

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{\lwe{} Dimension} & \textbf{Security (PQ)} & \textbf{Gates} & \textbf{Gas} & \textbf{Block \%} \\
\midrule
\textbf{$n{=}384$, $\sigma{=}8$} & \textbf{${\sim}112$-bit} & 64 & 1.8M & 3\% \\
\textbf{$n{=}384$, $\sigma{=}8$} & \textbf{${\sim}112$-bit} & 128 & 2M & 3\% \\
\textbf{$n{=}384$, $\sigma{=}8$} & \textbf{${\sim}112$-bit} & 256 & 3M & 5\% \\
\textbf{$n{=}384$, $\sigma{=}8$} & \textbf{${\sim}112$-bit} & 640 & 6M & 10\% \\
\bottomrule
\end{tabular}
\caption{\tlos{} gas costs by configuration (Tenderly-confirmed, 60M block limit). Security estimate of ${\sim}2^{112}$ PQ confirmed by lattice estimator for $n{=}384$ with Gaussian noise $\sigma{=}8$.}
\end{table}

\subsection{Storage Optimization: Seed-Derived $\vec{a}$ Vectors}

A key optimization reduces storage by 99\%: instead of storing full LWE ciphertexts $(a, b)$, we store only the $b$ values and derive $\vec{a}$ vectors deterministically on-chain from a circuit seed.

\textbf{Gate data format (optimized):}
\begin{itemize}
  \item 3 bytes: wire indices (active, control1, control2)
  \item 8 bytes: 4 $\times$ 2-byte $b$ values (one per truth table entry)
  \item \textbf{Total: 11 bytes/gate} (vs.\ $3 + 4(2n+2)$ bytes storing full ciphertexts)
\end{itemize}

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Config ($n{=}384$)} & \textbf{Gates} & \textbf{Storage} & \textbf{Old Format} & \textbf{Savings} \\
\midrule
Conservative & 64 & 704 bytes & 197 KB & 99.6\% \\
Balanced & 128 & 1.4 KB & 394 KB & 99.6\% \\
Standard & 256 & 2.8 KB & 788 KB & 99.6\% \\
Full & 640 & 7 KB & 1.97 MB & 99.6\% \\
\bottomrule
\end{tabular}
\caption{Storage comparison: seed-derived $\vec{a}$ vs.\ storing full ciphertexts.}
\end{table}

During evaluation, $\vec{a}$ vectors are regenerated via:
\[
\vec{a}_{g,t} = H(\mathsf{circuitSeed} \| \text{``A''} \| g \| t) \mod q
\]
where $g$ is the gate index and $t \in \{0,1,2,3\}$ is the truth table index.

\subsection{Deployment Scheme}

\textbf{Shared circuit deployment:} Circuit data can be deployed once and reused across multiple contract instances. We illustrate with an NFT mystery box where trait generation logic is hidden:

\begin{enumerate}
  \item \textbf{Deploy circuit data (one-time):} Store gate topology and $b$ values via SSTORE2. For 256 gates at $n{=}384$: ${\sim}2.8$ KB, fits in single SSTORE2 contract (${\sim}615$K gas).
  
  \item \textbf{Deploy NFT contract:} Contract references the shared \texttt{circuitDataPointer}. Instance deployment costs ${\sim}100$K gas (no circuit data duplication).
  
  \item \textbf{Mint with hidden traits:} Each \texttt{mint()} call internally evaluates the obfuscated circuit to compute traits from \texttt{(tokenId, entropy)}.
\end{enumerate}

\subsection{View vs.\ Transaction Costs}

The \texttt{check()} function is a \texttt{view}---it can be called locally via \texttt{eth\_call} with \textbf{no gas payment}. Only state-changing operations require on-chain gas:

\begin{table}[h]
\centering
\begin{tabular}{@{}llcc@{}}
\toprule
\textbf{Function} & \textbf{Type} & \textbf{Gas Cost} & \textbf{Notes} \\
\midrule
\texttt{check(input)} & view & \textbf{Free} & Local simulation \\
\texttt{commit(hash)} & tx & ${\sim}45$K & Store commitment \\
\texttt{reveal(input)} / \texttt{mint()} & tx & 3M & Executes \texttt{\_evaluate()} \\
SSTORE2 deploy & tx & ${\sim}615$K & One-time, shared \\
\bottomrule
\end{tabular}
\caption{Gas costs by operation type ($n{=}384$, 256 gates).}
\end{table}

\textbf{Implications:}
\begin{itemize}
  \item \textbf{Attackers} can brute-force \texttt{check()} locally without paying gas. On GPU, attackers can achieve $10^5$--$10^6$ guesses/sec (see \S\ref{sec:gpu-attack}).
  \item \textbf{Legitimate users} pay 1.8M--6M gas only once when executing the state-changing operation (\texttt{reveal()}, \texttt{mint()}, etc.).
\end{itemize}

\begin{table}[h]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Config ($n{=}384$, $\sigma{=}8$)} & \textbf{Gates} & \textbf{Evaluation Gas} & \textbf{Block \%} \\
\midrule
Conservative & 64 & 1.8M & 3\% \\
Balanced & 128 & 2M & 3\% \\
Standard & 256 & 3M & 5\% \\
Full & 640 & 6M & 10\% \\
\bottomrule
\end{tabular}
\caption{Gas costs with seed-derived $\vec{a}$ vectors (Tenderly-confirmed, 60M block limit).}
\end{table}

\textbf{Security vs.\ gas tradeoff:} For $n{=}384$ with Gaussian noise $\sigma{=}8$, all configurations provide ${\sim}2^{112}$ PQ security:
\begin{itemize}
  \item 64 gates: 1.8M gas (3\% of block)
  \item 128 gates: 2M gas (3\% of block)
  \item 256 gates: 3M gas (5\% of block)
  \item 640 gates: 6M gas (10\% of block)
\end{itemize}

%------------------------------------------------------------------------------
\section{Attack Evaluation}
%------------------------------------------------------------------------------

We empirically validated \tlos{} against 14 attack implementations across 6 categories.

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Attack} & \textbf{Type} & \textbf{Defense} & \textbf{Status} \\
\midrule
\multicolumn{4}{l}{\textit{Structural Attacks (Defeated by Topology Layer)}} \\
Compression & Structural & Topology & \textsc{Blocked} \\
PatternMatch & Structural & Topology & \textsc{Blocked} \\
Structural (Butterfly) & Structural & Topology & \textsc{Blocked} \\
\midrule
\multicolumn{4}{l}{\textit{Statistical Attacks (Defeated by Wire Selection)}} \\
Statistical (Chi-squared) & Statistical & Topology & \textsc{Blocked} \\
DiagonalCorrelation & Statistical & Topology & \textsc{Blocked} \\
\midrule
\multicolumn{4}{l}{\textit{Semantic Attacks (Blocked by LWE Layer)}} \\
RainbowTable & Semantic & LWE & \textsc{Blocked} \\
\midrule
\multicolumn{4}{l}{\textit{Brute-Force Attacks (Blocked by Planted LWE Puzzle)}} \\
GPU Brute-Force & Brute-force & Puzzle & \textsc{Blocked} \\
Low-Entropy Search & Brute-force & Puzzle & \textsc{Blocked} \\
\midrule
\multicolumn{4}{l}{\textit{Advanced Attacks (Mitigated by Binary Output)}} \\
SAT/Key Recovery & Algebraic & Binary output & \textsc{Mitigated} \\
Oracle-Guided Synthesis & Learning & Binary output & \textsc{Mitigated} \\
CEGIS & Synthesis & Binary output & \textsc{Mitigated} \\
\bottomrule
\end{tabular}
\caption{Attack evaluation matrix. This is our evaluation taxonomy, not a universal security measure.}
\end{table}

\textbf{SAT/CEGIS results:} On 64-wire/640-gate circuits, off-the-shelf SAT solvers (MiniSat, CryptoMiniSat) timed out after 24 hours. This is empirical evidence, not a hardness proof.

\textbf{Important caveat:} These results validate that \tlos{} defeats \emph{our specific attack implementations} under \emph{our test distributions}. They should not be interpreted as a general guarantee against all possible attacks. Publishing the full attack suite enables independent verification and discovery of new attack vectors.

\subsection{Lattice Attack Validation}
\label{sec:attack-validation}

To validate our security estimates, we implemented direct lattice attacks against \tlos{} instances using fpylll~\cite{fpylll}:

\textbf{Experimental setup:}
\begin{itemize}
  \item Generated \tlos{} \lwe{} instances with uniform secrets: $s = H(\mathsf{secret}) \in \mathbb{Z}_q^n$
  \item Built Kannan embedding lattices for BKZ reduction
  \item Ran BKZ with progressive block sizes ($\beta = 20, 30, 40, 50$)
  \item Measured success rate and running time
\end{itemize}

\textbf{Results:}
\begin{itemize}
  \item \textbf{$n{=}16$:} BKZ-50 with 200+ basis updates \emph{failed} to recover the secret. Primal attack ineffective due to large secret norm ($\|s\| \approx \sqrt{n} \cdot q/2$).
  \item \textbf{$n{=}128$:} Attack infeasible with current hardware. BKZ reduction would require block sizes $\beta > 300$, estimated at $2^{100}+$ core-hours. Validates ${\sim}203$-bit security estimate.
\end{itemize}

\textbf{Key finding:} The uniform-secret variant of \lwe{} used in \tlos{} is harder to attack than small-secret \lwe{}. Standard primal (uSVP) attacks assume the secret has small norm; when $s$ is uniform, these attacks fail. Dual attacks remain applicable but require larger BKZ block sizes.

\textbf{Reproducibility:} Attack code is available at \url{https://github.com/igor53627/tlos} (scripts/tlos\_attack.py).

\subsection{Layer Ablation}

We evaluated attack resistance with different layer combinations to understand each layer's contribution:

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}lccccc@{}}
\toprule
\textbf{Configuration} & \textbf{Struct.} & \textbf{Stat.} & \textbf{Sem.} & \textbf{Mix} & \textbf{Brute} \\
\midrule
Baseline (none) & 0/3 & 0/2 & 0/1 & 0/1 & 0/2 \\
Topology only & 3/3 & 2/2 & 0/1 & 0/1 & 0/2 \\
+ LWE & 3/3 & 2/2 & 1/1 & 0/1 & 0/2 \\
+ Wire Binding & 3/3 & 2/2 & 1/1 & 1/1 & 0/2 \\
+ Puzzle (Full \tlos{}) & 3/3 & 2/2 & 1/1 & 1/1 & 2/2 \\
\bottomrule
\end{tabular}
\caption{Layer ablation: attacks defeated per category. Struct.=Structural, Stat.=Statistical, Sem.=Semantic, Mix=Mix-and-Match, Brute=Brute-Force.}
\label{tab:ablation}
\end{table}

\textbf{Key findings:}
\begin{itemize}
  \item \textbf{Topology alone} defeats structural attacks (compression, pattern matching, butterfly detection) and statistical attacks (chi-squared, diagonal correlation), but \emph{not} semantic attacks.
  \item \textbf{LWE layer} is necessary to defeat semantic attacks (RainbowTable). Without hidden control functions, an attacker can evaluate subcircuits and match against known truth tables.
  \item \textbf{Wire binding layer} is necessary to prevent mix-and-match attacks. Without wire binding, an attacker can evaluate gates with inconsistent wire values from different execution paths.
  \item \textbf{Planted LWE puzzle} is necessary to defeat brute-force attacks on low-entropy inputs. Without the puzzle, GPU brute-force can crack $2^{30}$ entropy secrets in seconds.
\end{itemize}

\subsection{GPU/ASIC Attack Cost Analysis}
\label{sec:gpu-attack}

While naive CPU execution achieves only ${\sim}10$ guesses/second, our analysis focuses on the high-throughput GPU threat model~\cite{GPUFalcon23,GPUHybrid25}, where attackers can achieve $10^5$--$10^6$ guesses/second.

\textbf{Workload per guess:} For $n{=}384$ with Gaussian noise $\sigma{=}8$, $k{=}64$--$640$ gates:
\begin{itemize}
  \item Expand secret: $s = H(\mathsf{guess})$ to 384 $\times$ 16-bit elements
  \item Compute $k$ inner products of dimension 384 over $\mathbb{Z}_q$
  \item Total: ${\sim}k \times n \approx 2.5 \times 10^4$--$2.5 \times 10^5$ multiply-adds per guess
\end{itemize}

\textbf{GPU throughput estimates:} The workload is memory-bandwidth bound (reading the $A$ matrix):

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Hardware} & \textbf{Bandwidth} & \textbf{$k{=}256$} & \textbf{$k{=}1024$} & \textbf{Notes} \\
\midrule
RTX 4090 & 1 TB/s & ${\sim}2 \times 10^6$ g/s & ${\sim}6 \times 10^5$ g/s & Consumer GPU \\
A100 80GB & 2 TB/s & ${\sim}4 \times 10^6$ g/s & ${\sim}1 \times 10^6$ g/s & Datacenter GPU \\
100$\times$ A100 cluster & 200 TB/s & ${\sim}4 \times 10^8$ g/s & ${\sim}1 \times 10^8$ g/s & Cloud-scale \\
\bottomrule
\end{tabular}
\caption{Estimated GPU attack throughput (guesses/second). Based on memory bandwidth limits; actual throughput may be 10--30\% lower due to kernel overhead.}
\end{table}

\textbf{ASIC estimates:} A custom 384-wide MAC array at 1 GHz could achieve ${\sim}10^6$--$10^8$ guesses/sec per chip. A dedicated attacker with 100 ASICs could reach ${\sim}10^{10}$ guesses/sec.

\textbf{Implications for secret entropy:}

\begin{table}[h]
\centering
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Secret Entropy} & \textbf{Time (1 GPU)} & \textbf{Time (100 GPUs)} \\
\midrule
$2^{20}$ (${\sim}10^6$, 6-word phrase) & 1--10 seconds & $<$1 second \\
$2^{30}$ (${\sim}10^9$, 9-word phrase) & 17 minutes -- 2.8 hours & 10 seconds -- 2 minutes \\
$2^{40}$ (${\sim}10^{12}$) & 12 days -- 4 months & 3 hours -- 1 day \\
$2^{50}$ & 35 years -- 350 years & 4 months -- 3.5 years \\
$2^{64}$ & $10^7$ years & $10^5$ years \\
\bottomrule
\end{tabular}
\caption{Time to brute-force secrets of various entropy levels. Assumes $10^5$--$10^6$ guesses/sec/GPU.}
\end{table}

\textbf{Recommendation:} \tlos{} is suitable for secrets with $\geq 2^{40}$ entropy (12+ word phrases, 40+ bit numeric ranges) against well-funded attackers, or $\geq 2^{30}$ entropy against casual attackers with single GPUs. For low-entropy secrets ($<2^{30}$), combine with rate-limiting or time-locks.

%------------------------------------------------------------------------------
\section{Implementation}
%------------------------------------------------------------------------------

\subsection{Smart Contract Architecture}

\tlos{} requires no external infrastructure; just a standard smart contract. We illustrate with an NFT mystery box example where trait generation logic is hidden:

\begin{lstlisting}[caption=TLOSKitties Contract (simplified)]
contract TLOSKitties is ERC721 {
    bytes public circuitData;  // Obfuscated trait generator
    uint256 public totalMinted;
    
    struct Traits {
        uint8 fur;      // 0-15: common to legendary
        uint8 eyes;     // 0-7: patterns
        uint8 accessory; // 0-31: items
        uint8 background; // 0-7: colors
    }
    mapping(uint256 => Traits) public kittyTraits;
    
    function mint() external payable returns (uint256) {
        uint256 tokenId = ++totalMinted;
        // Entropy from blockhash + minter + tokenId
        bytes32 entropy = keccak256(abi.encode(
            blockhash(block.number - 1), msg.sender, tokenId
        ));
        // TLOS circuit maps entropy -> traits (logic hidden)
        uint256 output = evaluateTLOS(entropy);
        kittyTraits[tokenId] = decodeTraits(output);
        _mint(msg.sender, tokenId);
        return tokenId;
    }
    
    function decodeTraits(uint256 output) internal pure 
        returns (Traits memory) {
        return Traits(
            uint8(output & 0xF),        // fur: 4 bits
            uint8((output >> 4) & 0x7), // eyes: 3 bits
            uint8((output >> 7) & 0x1F),// accessory: 5 bits
            uint8((output >> 12) & 0x7) // background: 3 bits
        );
    }
}
\end{lstlisting}

\textbf{Why TLOS here?} With visible trait logic, minters could simulate which \texttt{(blockhash, sender, tokenId)} combinations yield rare traits and time their mints accordingly. TLOS hides the mapping: the circuit is deterministic and verifiable, but attackers cannot predict which inputs produce legendary fur.

\subsection{Gas Costs}

\begin{table}[h]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Variant} & \textbf{Operation} & \textbf{Gas ($n{=}384$)} & \textbf{\% of 60M} \\
\midrule
\tlos{} (64 gates) & \texttt{check()} & 1.8M & 3\% \\
\tlos{} (128 gates) & \texttt{check()} & 2M & 3\% \\
\tlos{} (256 gates) & \texttt{check()} & 3M & 5\% \\
\midrule
All & \texttt{commit()} & 47K & 0.08\% \\
All & \texttt{reveal()} & varies & varies \\
\bottomrule
\end{tabular}
\caption{Gas costs with $n{=}384$ \lwe{} dimension and seed-derived $\vec{a}$ vectors. Tenderly-measured.}
\end{table}

\subsection{Commit-Reveal Protocol}

To prevent front-running:
\begin{enumerate}
  \item \textbf{Commit:} User submits $H = \mathsf{hash}(\mathsf{sender} \| \mathsf{secret})$
  \item \textbf{Wait:} $k \geq 1$ blocks
  \item \textbf{Reveal:} User submits secret; contract verifies $H$ matches
\end{enumerate}

Sender binding prevents reward theft: an attacker copying the reveal transaction computes $\mathsf{hash}(\mathsf{attacker} \| \mathsf{secret}) \neq H$.

%------------------------------------------------------------------------------
\section{Wire Binding: Inter-Gate Consistency}
\label{sec:wire-binding}
%------------------------------------------------------------------------------

\tlos{} includes a full-rank linear hash (inspired by~\cite{MDS25}, but \emph{not} subspace-evasive in the formal sense) that binds wire values across gate evaluations, preventing mix-and-match attacks.

\subsection{The Mix-and-Match Attack}

Without wire binding, gates are evaluated independently. An attacker could potentially:
\begin{enumerate}
  \item Evaluate gate $i$ with crafted inputs $(w_1, w_2)$
  \item Evaluate gate $j$ with \emph{different} crafted inputs $(w'_1, w'_2)$
  \item Combine outputs to learn about circuit structure
\end{enumerate}

This is a \emph{mix-and-match attack}: using inconsistent intermediate values to probe the circuit.

\subsection{Wire Binding Construction}

The wire binding layer uses a full-rank linear map over $\mathbb{Z}_q$: $H_k(x) = A_k x \mod q$ where $A_k \in \mathbb{Z}_q^{64 \times 64}$ is derived from the circuit seed and batch index $k$. Each 128-gate batch updates the accumulator:
\[
\mathsf{acc}_{k+1} = H_k(\mathsf{acc}_k + \mathsf{wires}_k \mod q)
\]
where $\mathsf{wires}_k$ is the packed wire state after batch $k$, and addition is component-wise over $\mathbb{Z}_q^{64}$.

\textbf{Why 64$\times$64?} A full-rank matrix has trivial kernel (only zero vector), so $H$ is a bijection: each accumulator value has a unique preimage. Smaller matrices have large nullspaces where many wire states collide.

\textbf{Clarification:} The \emph{wire binding map} is linear and public (distinct from the encrypted LWE layer). It provides \emph{algebraic binding}, not cryptographic hiding or collision resistance. The linear system $Ax = y$ is trivially solvable; the security property is that forged wire values produce a different accumulator that cannot be ``repaired'' without recomputing a full consistent trace.

\subsection{Security Properties}

\textbf{What wire binding provides:}
\begin{itemize}
  \item Mix-and-match prevention: Gates cannot be evaluated with inconsistent inputs
  \item Execution trace binding: Full evaluation history is committed to a 1024-bit accumulator
  \item Algebraic binding: For full-rank $A$, each accumulator has unique preimage
\end{itemize}

\textbf{What wire binding does NOT provide:}
\begin{itemize}
  \item Cryptographic hiding: The linear map is public and invertible
  \item Collision resistance: Trivial to find $x$ given $Ax = y$
  \item Key extraction resistance: Still relies on the LWE layer for control function hiding
\end{itemize}

\subsection{Hybrid Security Model}

The full \tlos{} system has four security components:
\begin{itemize}
  \item \textbf{LWE with Gaussian noise} for control function hiding (${\sim}112$-bit post-quantum for $n{=}384$, $\sigma{=}8$)
  \item \textbf{Wire binding} for wire consistency (algebraic binding)
  \item \textbf{Planted LWE puzzle} for brute-force resistance ($3^{48} \approx 2^{76}$ minimum search space)
  \item \textbf{Hash preimage} for unlocking (${\sim}256$-bit)
\end{itemize}

The weakest link determines overall security. LWE with Gaussian noise provides computational hardness; wire binding provides integrity/binding; the puzzle ensures minimum brute-force cost regardless of input entropy.

%------------------------------------------------------------------------------
\section{Comparison with Hash-Compare Baseline}
\label{sec:hash-compare}
%------------------------------------------------------------------------------

A natural question is: why not just use a simple hash comparison?

\textbf{Hash-Compare Baseline:} For a simple predicate $P(x) = [x = \mathsf{secret}]$, one could deploy:
\begin{lstlisting}
function check(bytes32 x) returns (bool) {
    return keccak256(x) == storedHash;
}
\end{lstlisting}

This costs ${\sim}50$K gas and provides 256-bit preimage resistance. Why use \tlos{}'s 1.8M--6M gas for ${\sim}112$-bit LWE security?

\subsection{When Hash-Compare Suffices}

For simple ``guess the secret'' predicates, \textbf{hash-compare is equivalent or better}:
\begin{itemize}
  \item Lower gas (${\sim}50$K vs 1.8M--6M)
  \item Higher security (256-bit vs 112-bit PQ)
  \item Simpler implementation
\end{itemize}

\textbf{Use hash-compare} when: the predicate is $P(x) = [x = \mathsf{secret}]$ and revealing the \emph{structure} of the check (``it's a hash comparison'') is acceptable.

\subsection{When \tlos{} Adds Value}

\tlos{} provides value beyond hash-compare in scenarios where:

\begin{enumerate}
  \item \textbf{Predicate structure is sensitive:} If the attacker learning ``it's a simple hash check'' vs ``it's a complex multi-condition check'' is itself a vulnerability, \tlos{} hides this structure.
  
  \item \textbf{Complex predicates:} For predicates like $P(x) = [f(x) \in S]$ where $f$ is a non-trivial function (price thresholds, multi-party conditions, range checks), the predicate structure itself may reveal exploitable information.
  
  \item \textbf{Partial information leakage:} Hash-compare reveals nothing about wrong inputs. But for complex predicates, different wrong inputs might behave differently; \tlos{}'s wrong-key garbage property ensures all wrong inputs look equally random.
  
  \item \textbf{Composable obfuscation:} \tlos{} circuits can be composed. Multiple predicates can share structure without revealing which checks are related.
\end{enumerate}

\subsection{Multi-Bit Output: The Key Distinction}

A critical difference between hash-compare and \tlos{} is the \emph{output dimensionality}:

\begin{center}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Approach} & \textbf{Output} & \textbf{What's Hidden} \\
\midrule
Hash-compare & 1 bit (true/false) & Secret value only \\
\tlos{} circuit & $N$ bits (multi-bit) & Secret value + hidden computation \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Hash-compare} returns only a boolean: ``does your input match the secret?'' The output conveys no information beyond this binary answer.

\textbf{\tlos{} circuits compute a function.} When the correct input is provided, the circuit evaluates to a multi-bit output that can encode:
\begin{itemize}
  \item Hidden parameters (e.g., threshold offsets, multipliers)
  \item Computed results (e.g., PID controller outputs)
  \item Encoded payloads (revealed only on correct input)
\end{itemize}

\textbf{Example: Hidden Parameter Extraction.} Consider a DeFi application where the liquidation threshold is obfuscated:
\begin{lstlisting}
// Hash-compare: only confirms match
function check(bytes32 x) returns (bool) {
    return keccak256(x) == storedHash;  // 1-bit output
}

// TLOS: extracts hidden parameter on match
function extractThreshold(bytes32 x) returns (int256) {
    uint256 output = evaluateTLOS(x);
    if (output == GARBAGE) revert();    // wrong key
    // 8-bit output -> threshold offset (-20% to +20%)
    int256 offset = int256(output & 0xFF) - 128;
    return baseThreshold + (offset * baseThreshold / 128);
}
\end{lstlisting}

The circuit output encodes a hidden computation result, not just a match/no-match signal.

\subsection{Point Function with Hidden Payload}

Both hash-compare and \tlos{} implement \emph{point functions}: predicates that evaluate meaningfully only at $x = \mathsf{secret}$. The distinction is:
\begin{itemize}
  \item \textbf{Hash-compare:} Point function with 1-bit output (``yes, you found it'')
  \item \textbf{\tlos{}:} Point function with $N$-bit output (``here's the hidden result'')
\end{itemize}

For applications where the \emph{payload} matters (not just the confirmation), \tlos{} provides value that hash-compare cannot. The ${\sim}36\times$--$120\times$ gas premium buys multi-bit hidden computation, not stronger unlocking security.

\subsection{Honest Assessment}

For most honeypot use cases (``find the 256-bit secret''), hash-compare is the right choice. \tlos{}'s value is in:
\begin{itemize}
  \item \textbf{Multi-bit hidden output:} Revealing computed results, not just confirmation
  \item Hiding predicate \emph{complexity} (is it one condition or ten?)
  \item Hiding predicate \emph{structure} (which variables matter?)
  \item Providing a general framework for obfuscating arbitrary circuits (not just point functions)
\end{itemize}

We do not claim \tlos{} is always better than hash-compare. The choice depends on the application's threat model and whether multi-bit hidden output is required.

%------------------------------------------------------------------------------
\section{Limitations and Open Problems}
%------------------------------------------------------------------------------

\subsection{Theoretical Gaps}

\begin{enumerate}
  \item \textbf{Topology security is empirical:} We validate against our 9-class attack suite but cannot prove no faster attack exists. Future attacks may defeat the topology layer.
  
  \item \textbf{No iO guarantee:} We do not prove indistinguishability of obfuscations of equivalent circuits. \tlos{} obfuscations may be distinguishable.
  
  \item \textbf{Binary output assumption:} Security analysis assumes 1-bit output. Security degrades for circuits with multi-bit outputs or richer oracle interfaces.
\end{enumerate}

\subsection{Practical Concerns}

\begin{enumerate}
  \item \textbf{Gas costs:} \tlos{} with $n{=}384$ and Gaussian noise $\sigma{=}8$ requires 1.8M--6M gas (3--10\% of 60M block limit). This is practical for most operations.
  
  \item \textbf{Storage:} With seed-derived $\vec{a}$ vectors, circuit data requires only 11 bytes/gate (2.8 KB for 256 gates). Deployment costs are minimal.
  
  \item \textbf{Circuit size:} Larger circuits provide better security but higher gas costs. The 64-wire/640-gate configuration is a trade-off.
  
  \item \textbf{Expiry management:} Setting appropriate expiry timestamps requires application-specific knowledge.
  
  \item \textbf{EVM side channels:} Gas timing, storage access patterns, and other EVM-level side channels are out of scope.
\end{enumerate}

\subsection{What \tlos{} Does NOT Provide}

\begin{enumerate}
  \item \textbf{iO Security:} Obfuscations of equivalent circuits are not indistinguishable.
  
  \item \textbf{Forward Secrecy:} Expired secrets may be analyzed retroactively.
  
  \item \textbf{VBB Security:} Virtual black-box is impossible in general~\cite{BGI12}.
  
  \item \textbf{Universal Security:} We resist our 9-class taxonomy, not all possible attacks.
\end{enumerate}

%------------------------------------------------------------------------------
\section{Conclusion}
%------------------------------------------------------------------------------

\tlos{} provides practical circuit obfuscation for smart contracts through four-layer defense:

\begin{itemize}
  \item \textbf{Topology layer (heuristic):} Defeats structural and statistical attacks through wire selection patterns. Empirically validated.
  \item \textbf{LWE layer with Gaussian noise:} On-chain inner product computation hides control functions, defeating semantic attacks. ${\sim}2^{112}$ post-quantum security for $n{=}384$ with Gaussian noise $\sigma{=}8$, confirmed by lattice estimator.
  \item \textbf{Wire binding layer:} Full-rank linear hash (inspired by~\cite{MDS25}) binds wire values across gates, preventing mix-and-match attacks. Security: algebraic binding.
  \item \textbf{Planted LWE puzzle:} Forces minimum $3^{48} \approx 2^{76}$ brute-force search space via ternary LWE puzzle with planted solution. Protects low-entropy inputs from GPU brute-force attacks at 1.26M gas overhead.
\end{itemize}

\tlos{} achieves 11/11 resistance against our attack evaluation matrix at 1.8M--6M gas with $n{=}384$ and 64--640 gates. Security is based on standard LWE hardness with Gaussian noise; the wire binding layer provides algebraic consistency; the planted LWE puzzle ensures minimum brute-force cost. The system targets \emph{eventually-expiring secrets} where post-quantum security is desired.

\textbf{Key contributions:}
\begin{itemize}
  \item On-chain LWE with Gaussian noise ($\sigma{=}8$) inner products for control function hiding
  \item Wrong-key garbage property: attackers can simulate offline but learn nothing without the correct secret
  \item Wire binding: inter-gate consistency prevents mix-and-match attacks
  \item Planted LWE puzzle: minimum $2^{76}$ brute-force cost regardless of input entropy
  \item Practical gas costs (1.8M--6M) well within EVM block limits
  \item Honest comparison with hash-compare baseline (Section~\ref{sec:hash-compare})
\end{itemize}

\textbf{Limitations:} Topology security is heuristic, not proven. Gas costs (1.8M--6M) are practical for most operations. LWE security with $n{=}384$ and $\sigma{=}8$ provides ${\sim}2^{112}$ post-quantum security as confirmed by the lattice estimator.

\textbf{Future Work:}
\begin{itemize}
  \item Per-gate wire binding updates for stronger consistency
  \item Formal analysis of topology layer security
  \item Higher security parameters ($n \geq 256$) for NIST-level PQ security
\end{itemize}

%------------------------------------------------------------------------------
\bibliographystyle{abbrv}
\bibliography{refs}

%------------------------------------------------------------------------------
\appendix

\section{Wire Selection Implementation}

\begin{lstlisting}[caption=Wire Selection (Rust)]
fn select_wires(
    gate_idx: usize,
    num_wires: usize,
    usage: &mut [u32],
    rng: &mut impl Rng,
) -> (usize, usize, usize) {
    // Select active wire (prefer underused)
    let active = (0..num_wires)
        .min_by_key(|&w| usage[w])
        .unwrap();
    
    // Non-pow2 distances
    let non_pow2: Vec<usize> = (3..num_wires/2)
        .filter(|d| !d.is_power_of_two())
        .collect();
    
    let d1 = *non_pow2.choose(rng).unwrap();
    let d2 = *non_pow2.iter()
        .filter(|&&d| d != d1)
        .choose(rng).unwrap();
    
    let c1 = (active + d1) % num_wires;
    let c2 = (active + d2) % num_wires;
    
    // Update usage
    usage[active] += 2;
    usage[c1] += 1;
    usage[c2] += 1;
    
    (active, c1, c2)
}
\end{lstlisting}

\section{Empirical Attack Results}

Validation on 1000 random circuits ($w=64$ wires, $g=640$ gates) using our implemented attack suite:

\begin{table}[h]
\centering
\begin{tabular}{@{}lc@{}}
\toprule
\textbf{Attack} & \textbf{\tlos{} ($n{=}384$, $\sigma{=}8$)} \\
\midrule
Compression & 0\% \\
PatternMatch & 0\% \\
Structural & 0\% \\
Statistical & 0\% \\
DiagonalCorrelation & 0\% \\
RainbowTable & 0\% \\
\bottomrule
\end{tabular}
\caption{Attack success rates within our implemented attack suite. 0\% indicates no successful extraction across 1000 trials; this is empirical evidence, not a formal security proof.}
\end{table}

%------------------------------------------------------------------------------
\appendix
\section{Common Misunderstandings}
\label{app:misunderstandings}
%------------------------------------------------------------------------------

We address several misunderstandings that may arise when analyzing \tlos{}.

\subsection{``Known Plaintext Attack: Recover $s$ from $(a, b)$ pairs''}

\textbf{Claimed attack:} If the error term is small or structured, one might attempt to solve the system $b_i = \langle a_i, s \rangle + \mu_i \cdot (q/2) \mod q$ via Gaussian elimination in $O(n^3)$.

\textbf{Why it fails:} Two defenses prevent this. First, $\mu$ values (control function bits) are unknown to the attacker---$\mu$ \emph{is the secret we are hiding}. The attacker receives only a 1-bit oracle (valid/invalid) from the full circuit, not individual gate outputs. Second, even if $\mu$ were known, the Gaussian noise $e_i \sim \mathcal{N}(0, \sigma^2)$ with $\sigma{=}8$ prevents exact linear algebra; the system becomes noisy and Gaussian elimination fails.

\subsection{``White-Box Tracing: Observe $\mu$ via EVM Traces''}

\textbf{Claimed attack:} The EVM is white-box; trace execution and observe $\mathsf{diff} = b - \langle a, s \rangle$ to determine $\mu$ directly.

\textbf{Why it fails:} The decryption key $s = H(\mathsf{input} \| \mathsf{puzzleSolution})$ is derived from the input at evaluation time. When tracing with wrong input $x'$:
\[
\mathsf{diff} = b - \langle a, H(x') \rangle = \langle a, s_{\mathsf{correct}} - H(x') \rangle + \mu \cdot (q/2)
\]
Since $s_{\mathsf{correct}} \neq H(x')$, the term $\langle a, s_{\mathsf{correct}} - H(x') \rangle$ is essentially random, making $\mathsf{diff}$ uniformly distributed. The trace reveals nothing about $\mu$. \emph{Traces are visible but useless without the correct input.}

\subsection{``Structural Attack: Identify Gadgets to Predict $\mu$''}

\textbf{Claimed attack:} Real circuits use recognizable gadgets (adders, comparators). Identify these patterns to predict $\mu$ values, then solve for $s$.

\textbf{Why it fails:} \tlos{} circuits compute \emph{point functions}: $C(x) = 1$ iff $x = \mathsf{secret}$. There are no adders, comparators, or hash rounds---only a reversible permutation with one distinguished output. The topology layer further randomizes structure via non-pow2 wire distances and uniform wire usage. Standard gadget-recognition techniques do not apply to point-function reversible circuits.

\subsection{``Range Predicates: TLOS Supports $x < \mathsf{threshold}$''}

\textbf{Misunderstanding:} Table entries like ``Range 0--100K'' imply the circuit checks if input is within a numeric range.

\textbf{Clarification:} The table column is ``Secret Type,'' describing the \emph{entropy} of the secret, not the predicate. ``Range 0--100K'' means the secret is a number between 0 and 100,000 (100K possible values). The circuit still computes $C(x) = 1$ iff $x = \mathsf{secret}$---a point function, not a range predicate. All rows describe secrets of varying entropy checked via equality.

\subsection{``One-Time Break: Solve for $s$, Then Brute-Force Offline''}

\textbf{Claimed attack:} Solve the algebraic system to recover $s$ once, then check $\mathsf{Keccak}(\mathsf{guess}) = s$ at $10^9$/sec.

\textbf{Why it fails:} This attack treats $s$ as a static secret. It is not. The key is input-dependent:
\[
s = H(\mathsf{input} \| \mathsf{puzzleSolution})
\]
Each possible input produces a different $s$. There is no single ``target $s$'' to recover. Even if the attacker somehow recovered $s_{\mathsf{correct}}$, they would need to invert Keccak to find the input---which is computationally infeasible.

Furthermore, the algebraic system is massively underdetermined: 384 unknowns in $s$ plus 2560 unknown $\mu$ values, with only 2560 equations. There are ${\sim}2^{2560}$ possible $(s, \mu)$ pairs satisfying the constraints.

\subsection{``Security by Obscurity''}

\textbf{Concern:} \tlos{} relies on ``hiding code complexity'' rather than cryptographic hardness.

\textbf{Clarification:} \tlos{} does \emph{not} rely on hiding the code. The full bytecode, circuit data, and obfuscation scheme are public (Kerckhoffs's principle). Security comes from:
\begin{enumerate}
  \item \textbf{Input-dependent key:} $s = H(\mathsf{input})$ means wrong inputs produce garbage evaluations.
  \item \textbf{LWE hardness:} Recovering $\mu$ without $s$ requires solving LWE with Gaussian noise (${\sim}2^{112}$ security).
  \item \textbf{Layer 4 puzzle:} Forces minimum $2^{76}$ work per guess regardless of input entropy.
\end{enumerate}
The slowdown is \emph{per-guess}, enforced by cryptographic structure, not code obfuscation.

\subsection{``Static Ciphertext Attack: Use BDD on Public $(a, b)$ Pairs''}

\textbf{Claimed attack:} The $(a, b)$ pairs are static on-chain. Use Bounded Distance Decoding (BDD) to recover $s^*$ directly from the stored ciphertexts, exploiting ``structured'' $\mu$ values.

\textbf{Why it fails (numerical analysis):}

For BDD to succeed, the ``error'' term must be shorter than the Gaussian heuristic of the lattice. In \tlos{}, the error is $\mu \cdot (q/2)$ where $\mu \in \{0,1\}^m$.

\begin{center}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{Quantity} & \textbf{Value} \\
\midrule
LWE dimension $n$ & 384 \\
Samples $m$ & 2560 \\
Modulus $q$ & 65521 \\
Gaussian noise $\sigma$ & 8 \\
Expected error norm & $\sqrt{m} \cdot \sigma \approx 405$ \\
Gaussian heuristic & $\sqrt{n} \cdot q^{n/(n+m)} \approx 179$ \\
\textbf{Ratio} & \textbf{${\sim}2.3\times$ larger than heuristic} \\
\bottomrule
\end{tabular}
\end{center}

BDD requires error $<$ Gaussian heuristic. With our Gaussian noise $\sigma{=}8$, the error is still above the Gaussian heuristic threshold, making BDD infeasible. The lattice estimator confirms ${\sim}2^{112}$ security for these parameters.

\textbf{Why ``structured $\mu$'' does not help:}

The claim that $\mu$ is ``low-entropy'' because it describes a valid point function confuses two concepts:
\begin{itemize}
  \item \textbf{Local structure:} Each $\mu_i$ has bounded/sparse/correlated values (exploitable by lattice reduction)
  \item \textbf{Global constraint:} The composition of all gates produces correct input-output behavior (not lattice-exploitable)
\end{itemize}

\tlos{} has the latter, not the former. Individual $\mu$ values are essentially random bits---the ``valid circuit'' constraint is satisfied by exponentially many $\mu$ configurations. Lattice reduction exploits \emph{local} structure (e.g., sparse errors, ternary coefficients with bounded norm). It cannot exploit ``this sequence of random bits, when interpreted as gate operations, computes a point function.''

\textbf{Key point:} With Gaussian noise $\sigma{=}8$, error entries are small but the overall error norm still exceeds the Gaussian heuristic threshold for BDD success. The lattice estimator confirms security.

\end{document}
