\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\geometry{margin=1in}

\input{macros}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}

\lstset{
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray}\itshape,
  stringstyle=\color{red},
  breaklines=true,
  frame=single,
  xleftmargin=1em,
  xrightmargin=1em,
  columns=fullflexible,
  keepspaces=true,
  upquote=true,
}

\title{\tlos{}: Topology-Lattice Obfuscation for Smart Contracts}
\author{}
\date{}

\begin{document}
\maketitle

\begin{abstract}
We present \tlos{} (Topology-Lattice Obfuscation for Smart contracts), a practical circuit obfuscation framework for EVM that adds inter-gate wire consistency via a full-rank linear hash (inspired by~\cite{MDS25}). \tlos{} uses a three-layer security model: a topology layer that defeats structural and statistical attacks, a lattice layer using on-chain noiseless LWE-like (LBLO) inner products that defeats semantic attacks, and a wire binding layer that binds wire values across gates to prevent mix-and-match attacks.

\tlos{} achieves 9/9 resistance against our attack evaluation matrix at ${\sim}8.5$M gas with $n{=}128$ dimension and full-rank $64{\times}64$ wire binding. Control functions are hidden via LBLO ciphertexts (noiseless; security is heuristic, not based on standard LWE reductions); wire binding ensures that gate evaluations cannot be mixed-and-matched across different execution paths. Target applications include predicates with \emph{eventually-expiring} secrets (honeypots, sealed-bid auctions, lotteries, MEV protection). Deployment requires only a standard smart contract with timestamp-based expiry.
\end{abstract}

%------------------------------------------------------------------------------
\section{Introduction}
%------------------------------------------------------------------------------

Smart contracts on public blockchains are fully transparent: anyone can read the bytecode, analyze the logic, and exploit vulnerabilities before the contract owner can react. This transparency fundamentally conflicts with applications requiring hidden logic or \emph{low-entropy secret protection}:

\begin{itemize}
  \item \textbf{DeFi:} Hidden liquidation thresholds, private stop-loss triggers, dark limit orders
  \item \textbf{Wallet recovery:} Human-memorable recovery codes, on-chain wills, dead man's switches
  \item \textbf{Gaming \& NFTs:} On-chain puzzles, sealed-bid auctions, mystery box trait generation
  \item \textbf{Identity:} ENS recovery codes, one-time delegation codes, multi-code access control
\end{itemize}

The core problem: EVM has no memory-hard KDF (Argon2/scrypt) as a precompile. Keccak256 can be brute-forced at ${\sim}1$ns/guess, making low-entropy secrets (human phrases, small ranges) trivially crackable offline. \tlos{} transforms each guess into an expensive LBLO-style (noiseless LWE-like) inner-product computation (${\sim}100$ms/guess), a $10^8\times$ slowdown that makes dictionary attacks economically prohibitive.

Traditional circuit obfuscation aims for \emph{permanent} security: given the obfuscated circuit $\obf(C)$, no efficient adversary can ever extract useful information beyond input-output behavior. The best theoretical constructions achieve indistinguishability obfuscation (iO) from LWE~\cite{JLS21,GP21,CLW25}, but with overhead exceeding $10^6\times$; far too expensive for on-chain deployment.

\subsection{Our Approach: Three-Layer Obfuscation}

We take a practical approach: \emph{resist known attack classes} through three complementary security layers.

\begin{center}
\framebox{\parbox{0.9\textwidth}{
\textbf{Three-Layer Security Model:}

\begin{enumerate}
  \item \textbf{Layer 1 (Topology):} Structural mixing defeats structural and statistical attacks through wire selection patterns (non-pow2 distances, uniform wire usage, irregular layers). \emph{Security: heuristic, empirically validated.}
  
  \item \textbf{Layer 2 (LBLO):} On-chain inner product computation defeats semantic attacks (RainbowTable). Control functions hidden via noiseless LWE-like ciphertexts. \emph{Security: heuristic ${\sim}2^{98}$ PQ cost for known attacks on our LBLO construction; not standard LWE (see \S\ref{sec:lblo}).}
  
  \item \textbf{Layer 3 (Wire Binding):} Full-rank linear hash binds wire values across gate evaluations, preventing mix-and-match attacks (see \S\ref{sec:wire-binding}). \emph{Security: algebraic binding via bijective map over $\mathbb{Z}_q^{64}$ (not cryptographic hiding).}
\end{enumerate}

\textbf{Key mechanism:} Wrong-key decryption yields garbage; wire binding ensures consistent execution traces.
}}
\end{center}

\subsection{Key Insight: Wrong-Key-Gives-Garbage}

The RainbowTable attack is \emph{semantic}: it matches circuit behavior (truth tables of subcircuits) rather than structure. The attack proceeds by:

\begin{enumerate}
  \item Extracting subcircuits from the obfuscated circuit
  \item Evaluating each subcircuit on sample inputs to compute its truth table
  \item Matching the truth table against a pre-computed lookup table
\end{enumerate}

Topology-only defenses cannot block this attack because any structural transformation preserves the semantic behavior of reversible circuits.

\textbf{The LBLO layer defeats step 2 via wrong-key garbage.} Control functions are hidden via LBLO ciphertexts (noiseless LWE-like; see Definition~\ref{def:lblo}) where the encryption key $s_{\mathsf{enc}} = H(\mathsf{secret})$ is derived from the \emph{correct} secret. An attacker with full bytecode can simulate circuit evaluation on any candidate input $x'$, but:
\begin{itemize}
  \item The derived evaluation key $s(x') = H(x')$ will be \emph{wrong} for $x' \neq \mathsf{secret}$
  \item Evaluating with the wrong key produces random/incorrect control function bits (garbage)
  \item Recovering the correct CFs without knowing the secret appears to require solving the LBLO problem; this is heuristic and not based on a standard LWE reduction
\end{itemize}

\textbf{Important:} Attackers \emph{can} simulate the circuit offline; this is not a ``restricted oracle'' in the sense of blocking evaluation. The defense is that wrong-key evaluation yields \emph{meaningless} subcircuit semantics. The on-chain contract reinforces this by exposing only a 1-bit oracle (true/false), limiting information leakage per query.

\subsection{Contributions}

\begin{enumerate}
  \item \textbf{\tlos{} Framework:} A three-layer obfuscation framework for EVM combining topology-based structural mixing, on-chain LBLO (noiseless LWE-like) inner products, and a full-rank wire binding layer. Our implementation uses $n{=}128$ LWE dimension and a $64{\times}64$ binding matrix, achieving ${\sim}8.5$M gas (28\% of block) and 662\,KB storage for 640 gates with 9/9 resistance in our attack evaluation matrix.
  
  \item \textbf{Structural Mixing:} Wire selection algorithm defeating structural and statistical attacks through non-pow2 distances, uniform wire usage, and irregular layers. Security is heuristic and empirically validated.
  
  \item \textbf{Wrong-Key Garbage Property:} Attackers can simulate evaluation offline with any candidate input, but wrong keys yield garbage control function bits. The on-chain 1-bit oracle limits information leakage per query.
  
  \item \textbf{On-Chain LBLO (LWE-like):} Control functions hidden via noiseless LWE-like ciphertexts (LBLO; see Definition~\ref{def:lblo}) with full inner product computation on-chain. No hints or shortcuts; recovering control-function bits without the secret appears to require solving LBLO.
  
  \item \textbf{Post-Quantum Resistance (Conjectured):} Security of control-function hiding relies on the conjectured hardness of LBLO. Our ${\sim}2^{98}$ PQ estimate is based on heuristic modeling with the LWE estimator (see Table~\ref{tab:lwe-security}), not on standard LWE reductions.
  
  \item \textbf{Attack Evaluation:} Empirical validation against 14 attack implementations across 6 categories.
\end{enumerate}

\subsection{Scope and Limitations}

\textbf{What \tlos{} provides:}
\begin{itemize}
  \item Computational security based on \emph{conjectured} hardness of our noiseless LBLO construction (modeled heuristically via the LWE estimator; see Table~\ref{tab:lwe-security} for rough complexity estimates) plus empirical heuristics (topology layer)
  \item Attack resistance (9/9 in our evaluation matrix; not a universal security claim)
  \item Practical gas costs (${\sim}8.5$M for $n{=}128$, 28\% of block limit)
  \item Conjectured post-quantum resistance (to the extent that LBLO resists quantum attacks at our parameter sizes; no worst-case lattice reduction is known for LBLO)
  \item Public evaluation: no secret keys required to evaluate the circuit on-chain
  \item Wrong-key garbage property: attackers can simulate offline but wrong keys yield garbage outputs
\end{itemize}

\textbf{Offline simulation:} An attacker with full bytecode can simulate circuit evaluation on any candidate input $x'$ offline. This is \emph{not} blocked. The security property is that wrong keys ($x' \neq \mathsf{secret}$) yield garbage control function bits, so the attacker learns nothing useful. Only the correct key produces meaningful evaluation.

\textbf{What \tlos{} does NOT provide:}
\begin{itemize}
  \item Permanent indistinguishability obfuscation (iO); we do not claim that obfuscations of equivalent circuits are indistinguishable
  \item Universal security against all possible attacks; we resist our 9-class taxonomy only
  \item Forward secrecy for long-lived secrets (expired secrets may be analyzed retroactively)
  \item Protection against protocol logic bugs, economic/incentive attacks, or EVM-level side channels
  \item Security after LBLO compromise: if an adversary recovers all control function bits (e.g., by breaking the underlying LBLO instances), the circuit becomes a fully specified reversible circuit that can be inverted gate-by-gate in linear time. The topology layer offers no post-compromise security; it only increases the cost of \emph{pre-compromise} structural and statistical attacks
\end{itemize}

\subsection{Related Work}

\textbf{Indistinguishability Obfuscation.} The breakthrough work of~\cite{GGH13} established iO from multilinear maps. Recent constructions achieve iO from LWE~\cite{JLS21,GP21,CLW25}. Diamond iO~\cite{SBP25} provides a practical construction but requires 100GB+ and is limited to ${\sim}8$K input bits. These provide provable security under standard assumptions but are not deployable on-chain.

\textbf{Compute-and-Compare Obfuscation.} Wichs and Zirdelis~\cite{WZ17} and Goyal, Koppula, and Waters~\cite{GKW17} achieve VBB security for compute-and-compare programs (predicates of the form $P(x) = [f(x) = s]$) under LWE. Our application of \cac{} to control function hiding is inspired by this work.

\textbf{Local Mixing.} Canetti et al.~\cite{CCMR24} explore obfuscation via local, functionality-preserving perturbations in reversible circuits. Our topology layer uses related ideas but focuses on attack-resistant construction rather than perturbation-based rerandomization.

\textbf{Smart Contract Privacy.} Existing approaches use ZK-SNARKs (e.g., Tornado Cash for private transfers) or Trusted Execution Environments (e.g., Secret Network). \tlos{} provides a new point in the design space: on-chain obfuscation without trusted hardware or external proving infrastructure.

%------------------------------------------------------------------------------
\section{Application Scope}
\label{sec:app-scope}
%------------------------------------------------------------------------------

\subsection{Deployment Constraints}

\tlos{} is designed for environments with the following constraints:

\begin{itemize}
  \item \textbf{On-chain only:} No off-chain computation or trusted servers available
  \item \textbf{No zk-SNARKs:} Proof systems unavailable, too complex, or undesirable
  \item \textbf{No private L2:} Must deploy on public L1 (Ethereum mainnet, L2 rollups)
  \item \textbf{Gas cost is acceptable:} At 0.03 gwei, 8.5M gas $\approx$ \$0.80, negligible for most applications
\end{itemize}

Under these constraints, \tlos{} provides a practical mechanism to make low-entropy secret verification expensive on EVM. No memory-hard KDF (Argon2, scrypt, bcrypt) exists as an EVM precompile. Keccak256 can be brute-forced at ${\sim}1$ns/guess; \tlos{} requires ${\sim}100$ms/guess, a $10^8\times$ slowdown.

\subsection{Practical Use Cases}

\subsubsection{DeFi: Hidden Strategy Parameters}

\begin{itemize}
  \item \textbf{Private liquidation thresholds:} Users can hide their liquidation trigger prices inside a TLOS circuit. MEV bots cannot front-run liquidations if they don't know the threshold. The circuit checks if \texttt{(oracle\_price, user\_code)} satisfies secret conditions before triggering.
  
  \item \textbf{Hidden stop-loss / take-profit:} Trading vaults embed strategy parameters (price levels, exposure limits) in obfuscated circuits. Attackers cannot reverse-engineer the exact conditions that trigger position changes.
  
  \item \textbf{Dark limit orders:} Price bands and slippage tolerances are hidden. Even if bid/ask ranges are from a small domain (1000 discrete ticks), TLOS makes dictionary attacks prohibitively slow.
\end{itemize}

\subsubsection{Wallet Recovery \& Inheritance}

\begin{itemize}
  \item \textbf{Human-memorable recovery codes:} Smart wallets can use 6-word recovery phrases protected by TLOS. With keccak, a $10^6$-word dictionary is cracked in $<$1ms; with TLOS, the same search takes ${\sim}28$ hours per core.
  
  \item \textbf{On-chain wills:} Family passphrases unlock inheritance. The distribution structure (who gets what percentage) is hidden inside the circuit. Multiple heirs can have different secrets encoded.
  
  \item \textbf{Dead man's switch:} Liveness criteria and claim codes are both obfuscated. Attackers cannot mimic the expected ``alive'' pattern because they don't know what's being checked.
\end{itemize}

\subsubsection{Gaming \& NFTs}

\begin{itemize}
  \item \textbf{On-chain puzzles:} Low-entropy riddle answers are protected from GPU brute-force. Honest human solvers compete fairly; automated mass-guessing becomes economically prohibitive.
  
  \item \textbf{Sealed-bid auctions:} Bids from small domains (0--10,000 price levels) cannot be dictionary-attacked. Each guess requires expensive TLOS evaluation.
  
  \item \textbf{Mystery box trait generation:} The algorithm mapping \texttt{(tokenId, entropy)} to traits is obfuscated. Minters cannot predict or steer for rare outcomes.
\end{itemize}

\subsubsection{Identity \& Access Control}

\begin{itemize}
  \item \textbf{ENS recovery:} High-value ENS names can be protected by human-memorable codes that would be trivially crackable with keccak.
  
  \item \textbf{One-time delegation codes:} Short numeric codes (6 digits) grant temporary access. TLOS makes $10^6$ guesses take hours instead of milliseconds.
  
  \item \textbf{Multi-code access:} OR of $N$ event codes with hidden structure; attackers don't know how many codes exist or their format.
\end{itemize}

\subsection{When NOT to Use TLOS}

\tlos{} is \emph{not} designed for:

\begin{itemize}
  \item \textbf{High-entropy secrets:} Random 256-bit keys are already secure with keccak256.
  \item \textbf{Long-term keys:} FHE decryption keys, signing keys, or secrets that must remain confidential for decades.
  \item \textbf{When alternatives exist:} If zk-SNARKs, private L2s, or off-chain KDFs are available and acceptable, they may be simpler.
\end{itemize}

For long-lived secrets, an adversary can analyze the circuit for arbitrarily long time. While our LBLO construction provides estimated computational security (${\sim}2^{98}$ PQ, heuristic), we do not claim this is sufficient for secrets requiring decades of protection.

%------------------------------------------------------------------------------
\section{Preliminaries}
%------------------------------------------------------------------------------

\subsection{Learning With Errors}

\begin{definition}[\lwe{}~\cite{Regev05}]
For dimension $n$, modulus $q$, and error distribution $\chi$, the \lwe{}$_{n,q,\chi}$ problem is: given $(A, As + e \mod q)$ where $A \leftarrow \mathbb{Z}_q^{m \times n}$, $s \leftarrow \mathbb{Z}_q^n$, $e \leftarrow \chi^m$, distinguish from uniform $(A, u)$ where $u \leftarrow \mathbb{Z}_q^m$.
\end{definition}

\begin{theorem}[\lwe{} Hardness~\cite{Regev05,Pei09}]
For appropriate parameters, \lwe{} is as hard as worst-case lattice problems (e.g., GapSVP, SIVP) with polynomial approximation factors.
\end{theorem}

\lwe{} is believed quantum-resistant and forms the basis for post-quantum cryptography standards including ML-KEM~\cite{FIPS203}. Note that our parameters ($n{=}128$, $q{=}65521$) are \emph{much smaller} than NIST-standardized profiles (which use $n \geq 512$). See Table~\ref{tab:lwe-security} for security estimates based on the LWE Estimator~\cite{APS15}.

\subsection{Compute-and-Compare Obfuscation}

\begin{definition}[\cac{}~\cite{GKW17,WZ17}]
A \cac{} program $P_{f,t,m}$ is defined by a function $f$, a target value $t$, and a message $m$:
\[
P_{f,t,m}(x) = \begin{cases}
m & \text{if } f(x) = t \\
\perp & \text{otherwise}
\end{cases}
\]

A \cac{} obfuscator $\obf$ produces $\obf(P_{f,t,m})$ such that:
\begin{enumerate}
  \item \textbf{Correctness:} $\obf(P)(x) = P(x)$ for all $x$
  \item \textbf{Security:} No \ppt{} adversary can learn $m$ or $t$ except by finding $x$ such that $f(x) = t$
\end{enumerate}
\end{definition}

\begin{theorem}[\cac{} Security~\cite{WZ17}]
Under \lwe{} hardness, there exists a \cac{} obfuscator achieving VBB security for \cac{} programs.
\end{theorem}

We apply \cac{} to hide control functions: each gate's control function $c_f: \{0,1\}^2 \to \{0,1\}$ is encoded as a \cac{} program. The attacker cannot evaluate the gate without knowing the (encrypted) control function.

\subsection{Reversible Boolean Circuits}

\begin{definition}[Reversible Gate]
A reversible gate $g = (a, c_1, c_2, c_f)$ operates on $n$ wires where:
\begin{itemize}
  \item $a \in [n]$ is the active wire
  \item $c_1, c_2 \in [n] \setminus \{a\}$ are distinct control wires
  \item $c_f : \{0,1\}^2 \to \{0,1\}$ is the control function (one of 16 possible)
\end{itemize}
Gate evaluation: $\mathit{state}'[a] = \mathit{state}[a] \xorgate c_f(\mathit{state}[c_1], \mathit{state}[c_2])$
\end{definition}

\begin{proposition}
Every reversible gate is self-inverse: $g(g(s)) = s$ for all states $s$.
\end{proposition}

\begin{definition}[Circuit]
A reversible circuit $C = (g_1, \ldots, g_m)$ is a sequence of reversible gates evaluated sequentially.
\end{definition}

The self-inverse property enables commit-reveal protocols where the solver demonstrates knowledge of the secret without revealing it in the commit phase.

%------------------------------------------------------------------------------
\section{The \tlos{} Framework}
%------------------------------------------------------------------------------

\subsection{System Architecture}

\tlos{} consists of three layers, deployed as a single smart contract:

\begin{enumerate}
  \item \textbf{Topology Layer:} Structural mixing that defeats structural and statistical attacks through wire selection patterns. No cryptographic primitives; purely structural.
  
  \item \textbf{LBLO Layer (LWE-like):} On-chain LBLO inner-product computation hides control functions, defeating semantic attacks by preventing subcircuit evaluation (see Definition~\ref{def:lblo}).
  
  \item \textbf{Wire Binding Layer:} Full-rank $64{\times}64$ linear hash binds wire values across gates, preventing mix-and-match attacks. Updated every 128 gates for gas efficiency.
\end{enumerate}

\textbf{Deployment:} A single smart contract with:
\begin{itemize}
  \item Circuit data (gates encoded as bytes)
  \item Expected output hash (for verification)
  \item Expiry timestamp (after which the secret is no longer protected)
  \item Commit-reveal storage (for front-running protection)
\end{itemize}

No external infrastructure is required.

\subsection{Actor Model}

We describe the protocol through three actors:

\begin{itemize}
  \item \textbf{Alice (Publisher):} Deploys the obfuscated circuit with an embedded secret. Sets the expiry timestamp based on the application's requirements.
  
  \item \textbf{Bob (User):} Attempts to solve the circuit by finding the secret. Uses commit-reveal to prevent front-running.
  
  \item \textbf{Charlie (Attacker):} Attempts to reverse-engineer the circuit. Has full access to bytecode, circuit data, and can make arbitrary queries.
\end{itemize}

\subsection{Threat Model}
\label{sec:threat-model}

\textbf{Adversary capabilities (Charlie has full access to):}
\begin{itemize}
  \item Complete bytecode and circuit data (all on-chain data is public)
  \item All historical queries and responses from any user
  \item \textbf{1-bit oracle access:} Can call \texttt{check(x)} with any input $x$ and receive true/false
  \item Unbounded offline computation time
  \item Knowledge of the obfuscation scheme (Kerckhoffs's principle)
\end{itemize}

\textbf{Adversary constraints:}
\begin{itemize}
  \item \textbf{On-chain oracle interface:} Each on-chain query returns only 1 bit (true/false), limiting information leakage per query. The attacker cannot query intermediate wire states via the contract.
  \item \textbf{Wrong-key garbage:} Attackers \emph{can} simulate evaluation offline with any candidate input $x'$. However, wrong keys yield garbage control function bits. The ciphertexts are encrypted under $s_{\mathsf{enc}} = H(\mathsf{secret})$; decrypting with $s(x') = H(x')$ for $x' \neq \mathsf{secret}$ produces random bits.
  \item \textbf{LBLO hardness (noiseless, LWE-like):} Recovering correct CF bits without knowing the secret requires solving the LBLO problem (Definition~\ref{def:lblo}). We estimate its cost heuristically using the LWE estimator (Table~\ref{tab:lwe-security}); standard LWE reductions do not apply because there is no noise.
  \item \textbf{Expiry:} After the timestamp, the secret may no longer be valuable (application-specific).
\end{itemize}

\textbf{Out of scope:}
\begin{itemize}
  \item EVM-level side channels (gas timing, storage access patterns)
  \item Multi-instance attacks across related contracts
  \item Protocol logic bugs or economic attacks
  \item Attacks on the commit-reveal mechanism itself
\end{itemize}

\subsection{Protocol Flow}

\textbf{Deployment (Alice):}
\begin{enumerate}
  \item Generate circuit $C$ that computes $C(x) = 1$ iff $x = \mathit{secret}$
  \item Apply topology layer: wire selection with non-pow2 distances, uniform usage
  \item Apply LBLO layer: encode control functions as LBLO (noiseless LWE-like) ciphertexts
  \item Deploy contract with circuit data (SSTORE2), expected output hash, and expiry timestamp
\end{enumerate}

\textbf{Solving (Bob):}
\begin{enumerate}
  \item Compute $H = \mathsf{hash}(\mathsf{sender} \| \mathsf{guess})$
  \item Call \texttt{commit(H)}
  \item Wait $k \geq 1$ blocks
  \item Call \texttt{reveal(guess)}
  \item If $C(\mathsf{guess}) = 1$, receive reward
\end{enumerate}

\textbf{Attack (Charlie):}
\begin{enumerate}
  \item Analyze circuit structure (topology layer blocks structural attacks)
  \item Attempt subcircuit evaluation (LBLO layer blocks; CFs hidden by LBLO ciphertexts)
  \item Resort to brute force ($2^{256}$ for 256-bit secrets; infeasible)
\end{enumerate}

%------------------------------------------------------------------------------
\section{The Topology Layer}
%------------------------------------------------------------------------------

The topology layer is a reversible circuit mixing structure designed to defeat structural and statistical attacks through wire selection, without cryptographic primitives.

\subsection{Design Principles}

\begin{enumerate}
  \item \textbf{Non-pow2 distances:} Control wires are selected at distances $d \notin \{1, 2, 4, 8, 16, \ldots\}$ from the active wire. This defeats butterfly/FFT pattern detection, which relies on power-of-2 distances.
  
  \item \textbf{Uniform wire usage:} Each wire is used as active/control with approximately equal frequency. This defeats chi-squared statistical attacks that look for non-uniform distributions.
  
  \item \textbf{Irregular layer sizes:} Layers have varying numbers of gates (e.g., 30--70 gates per layer for 256-wire circuits). This defeats regularity detection attacks.
  
  \item \textbf{64+ wires minimum:} Sufficient wire count defeats diagonal correlation attacks. With 64+ wires, Pearson correlation between input and output bits drops below 0.10.
\end{enumerate}

\subsection{Wire Selection Algorithm}

\textbf{Algorithm: Topology Wire Selection}

\textit{Input:} Wire count $n$, gate index $i$, wire usage counts $\mathsf{usage}[1..n]$

\begin{enumerate}
\item \textbf{Select active wire:} $a \gets \arg\min_{w} \mathsf{usage}[w]$ (prefer underused wires)

\item \textbf{Select control wires with non-pow2 distances:}
  \begin{itemize}
    \item $d_1 \gets$ random non-pow2 distance in $[3, n/2]$
    \item $d_2 \gets$ random non-pow2 distance in $[3, n/2]$, $d_2 \neq d_1$
    \item $c_1 \gets (a + d_1) \mod n$
    \item $c_2 \gets (a + d_2) \mod n$
  \end{itemize}

\item \textbf{Update usage:}
  \begin{itemize}
    \item $\mathsf{usage}[a] \gets \mathsf{usage}[a] + 2$ (active counts more)
    \item $\mathsf{usage}[c_1] \gets \mathsf{usage}[c_1] + 1$
    \item $\mathsf{usage}[c_2] \gets \mathsf{usage}[c_2] + 1$
  \end{itemize}

\item \textbf{Return} $(a, c_1, c_2)$
\end{enumerate}

\subsection{Topology Attack Resistance}

The topology layer provides empirical resistance against structural and statistical attacks in our evaluation:

\begin{table}[h]
\centering
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Attack} & \textbf{Type} & \textbf{Defense} & \textbf{Mechanism} \\
\midrule
Compression & Structural & Topology & No redundant/identity gates \\
PatternMatch & Structural & Topology & Random CF cycling \\
Structural (Butterfly) & Structural & Topology & Non-pow2 distances \\
Statistical (Chi-squared) & Statistical & Topology & Uniform wire usage \\
DiagonalCorrelation & Statistical & Topology & 64+ wires, irregular layers \\
\bottomrule
\end{tabular}
\caption{Topology layer resists structural and statistical attacks in our evaluation. Success should be read as ``no break found in our test suite,'' not ``provably secure.''}
\end{table}

\textbf{Key insight:} Unlike butterfly or derangement topologies that only rearrange gates, the topology layer has anti-attack properties \emph{built into wire selection}. The wire selection algorithm is designed specifically to resist known attack heuristics. \textbf{Important:} This is a closed-world evaluation against our implemented attacks. We cannot rule out future attacks that exploit structural patterns we have not anticipated. The topology layer should be viewed as raising the bar for structural analysis, not providing formal security guarantees.

%------------------------------------------------------------------------------
\section{The LBLO (LWE-Like) Layer}
%------------------------------------------------------------------------------

\subsection{The RainbowTable Problem}

The RainbowTable attack is \emph{semantic}: it matches circuit behavior (truth tables of subcircuits) rather than structure. For reversible circuits, topology-only methods cannot defeat this attack because the functional behavior is preserved under any structural transformation.

\textbf{Attack procedure:}
\begin{enumerate}
  \item \textbf{Extract subcircuit:} Identify a subsequence of gates $g_i, \ldots, g_j$
  \item \textbf{Evaluate subcircuit:} Compute truth table by running the subsequence on all possible inputs
  \item \textbf{Match against table:} Compare truth table against pre-computed lookup table of known functions
\end{enumerate}

If a match is found, the attacker learns the semantic function computed by that subcircuit, potentially revealing the embedded secret or simplifying further analysis.

\subsection{How On-Chain LBLO Blocks RainbowTable}

The wrong-key-gives-garbage property is the primary defense: attackers can simulate offline with any input, but wrong keys yield meaningless control function bits. The on-chain interface provides only a 1-bit full-circuit oracle. LBLO (noiseless LWE-like) cryptography provides conjectured computational hardness.

\begin{center}
\fbox{\parbox{0.9\textwidth}{
\textbf{On-Chain Inner Product:} Each gate's control function is encoded as an LBLO ciphertext $(a, b)$ where $b = \langle a, s \rangle + \mathsf{bit} \cdot q/2 \pmod q$ (no independent error term; see Definition~\ref{def:lblo} and \S\ref{sec:lblo}). The secret $s = H(\mathsf{input})$ is derived from the circuit input at evaluation time. The contract computes the inner product on-chain:

\smallskip
\texttt{s = keccak256(input) expanded to n u16 elements mod q}\\
\texttt{innerProd = sum(a[i] * s[i]) mod q}\\
\texttt{diff = (b - innerProd) mod q}\\
\texttt{cfBit = (diff > q/4) \&\& (diff < 3*q/4)}
\smallskip

\textbf{No hints stored:} Unlike compact formats that store $(b, \mathsf{hint})$ pairs (which allow offline CF recovery), \tlos{} stores full $(a, b)$ ciphertexts. Recovering CFs without the secret appears to require solving the LBLO problem (heuristically modeled via LWE estimators), not standard LWE.
}}
\end{center}

\begin{proposition}[LBLO Hides Subcircuit Semantics]
Assuming hardness of the LBLO problem (Definition~\ref{def:lblo}), no \ppt{} adversary can recover the \emph{true semantic behavior} (correct control function bits or truth tables) of a proper subcircuit without knowing the secret.
\end{proposition}

\begin{proof}[Proof sketch]
Let $C = (g_1, \ldots, g_m)$ be the circuit with control functions encoded as LBLO ciphertexts under key $s_{\mathsf{enc}} = H(\mathsf{secret})$. For any proper subsequence $S = (g_i, \ldots, g_j)$:

An attacker \emph{can} run $S$ with any guessed input $x'$, deriving $s(x') = H(x')$. However, for $x' \neq \mathsf{secret}$, decrypting the control function ciphertexts with the wrong key $s(x')$ yields random bits, not the true control function values.

Recovering the correct CF bits from $(a, b)$ without knowing $s_{\mathsf{enc}}$ requires solving the LBLO problem, which we conjecture is hard based on empirical evidence (\S\ref{sec:lblo}).

Therefore, while adversaries can \emph{execute} subcircuits, they cannot recover meaningful semantics without the secret (or solving LBLO).
\end{proof}

\begin{remark}
If our construction used standard noisy LWE instead of LBLO, this proposition would follow from~\cite{WZ17} under the LWE assumption. For our noiseless LBLO variant, security is \emph{conjectured} based on the attack analysis in \S\ref{sec:lblo}, not proven via reduction.
\end{remark}

\subsection{Control Function Encoding}

Each gate's control function $c_f: \{0,1\}^2 \to \{0,1\}$ (one of 16 possible) is represented as 4 LBLO ciphertexts (noiseless LWE-like), one for each truth table entry: $c_f \mapsto (\mathsf{ct}_{00}, \mathsf{ct}_{01}, \mathsf{ct}_{10}, \mathsf{ct}_{11})$.

\textbf{LBLO / LWE-Like Parameters:}
\begin{itemize}
  \item Modulus: $q = 65521$ (largest 16-bit prime)
  \item Dimension: $n = 128$ (deployed); $n \in \{16, 32\}$ for security estimates
  \item Sample count: $m = 2560$ (4 ciphertexts $\times$ 640 gates)
  \item Error term: \textbf{None} (deterministic encoding)
\end{itemize}

\textbf{Why no error term?} EVM requires deterministic execution; probabilistic decoding failures would break on-chain verification. Encryption is $b = \langle a, s \rangle + \mu \cdot (q/2) \mod q$ where $\mu \in \{0,1\}$ is the control-function bit. Decryption checks if $(b - \langle a,s \rangle) \mod q$ falls in $(q/4, 3q/4)$. Since there is no noise, decoding is \emph{perfect} (0\% error probability). The tradeoff: we lose standard \lwe{} semantic security guarantees but gain perfect correctness. Security relies on recovering $s$ without knowing the $\mu$ bits; the best known attack (subset guessing) requires $2^n$ work (see \S\ref{sec:lblo}).

\textbf{Storage per gate:} $n \cdot 2 + 2$ bytes per ciphertext, 4 ciphertexts per gate, plus 3 bytes for pins.
\begin{itemize}
  \item $n{=}16$: 139 bytes/gate, 89 KB total (640 gates)
  \item $n{=}32$: 267 bytes/gate, 171 KB total
  \item $n{=}128$: 1035 bytes/gate, 662 KB total
\end{itemize}

\textbf{On-chain evaluation:}
\begin{enumerate}
  \item Load wire state from input
  \item Derive secret $s = H(\mathsf{input})$ expanded to $n$ elements
  \item For each gate: load $(a, b)$ ciphertext, compute inner product, extract CF bit, XOR with active wire
  \item Compare final state hash with expected output
\end{enumerate}

%------------------------------------------------------------------------------
\section{Security Analysis}
%------------------------------------------------------------------------------

\subsection{Three-Layer Security Model}

\tlos{} provides security through three complementary layers:

\begin{enumerate}
  \item \textbf{Topology layer (heuristic):} Resists structural and statistical attacks in our evaluation through wire selection patterns that break known attack heuristics. Security is \emph{empirical} (no successful breaks found in testing), validated against our attack suite but not formally proven. Success should be interpreted as ``no break found,'' not ``provably secure.''
  
  \item \textbf{LBLO layer (heuristic):} Resists semantic attacks by hiding control functions via LBLO ciphertexts with on-chain inner products. Security is \emph{conjectured}, based on LBLO hardness (see Table~\ref{tab:lwe-security} and \S\ref{sec:lblo}).
  
  \item \textbf{Wire binding layer (algebraic):} Binds wire values across gates via full-rank linear hash, preventing mix-and-match attacks. Security is \emph{algebraic binding}, not cryptographic hiding.
\end{enumerate}

\textbf{Wrong-key garbage property:} Attackers can simulate offline but wrong keys yield garbage. The on-chain contract exposes only 1-bit output, limiting information per query.

\subsection{LBLO Security Estimates}

\textbf{Uniform-Secret LBLO.} A key property of \tlos{} is that the LBLO secret $s_{\mathsf{enc}} = H(\mathsf{secret})$ is \emph{uniform} over $\mathbb{Z}_q^n$, not a small-coefficient secret as in standard LWE assumptions. This arises naturally from expanding a cryptographic hash output to $n$ elements modulo $q$. The uniform-secret variant is \emph{harder} to attack than small-secret LWE: primal (uSVP) attacks rely on finding short vectors $(s, e)$ in a lattice, but when $s$ has norm ${\sim}\sqrt{n} \cdot q/2$ rather than ${\sim}\sqrt{n}$, the attack fails. We validated this empirically: BKZ-50 reduction on $n{=}16$ instances failed to recover the secret after 200+ basis updates.

Table~\ref{tab:lwe-security} presents heuristic security estimates for our LBLO construction, modeled as uniform-secret LWE for the purpose of applying the LWE Estimator. These estimates use BKZ lattice reduction with the ``Core-SVP'' cost model. \textbf{Note:} Standard LWE reductions do not apply to LBLO; these numbers are rough complexity yardsticks.

\begin{table}[h]
\centering
\label{tab:lwe-security}
\begin{tabular}{@{}lcccl@{}}
\toprule
\textbf{Dimension $n$} & \textbf{Classical} & \textbf{Quantum} & \textbf{Gas} & \textbf{Notes} \\
\midrule
$n{=}16$ & ${\sim}22$-bit & ${\sim}20$-bit & 0.74M & Toy parameters (experiments only) \\
$n{=}32$ & ${\sim}51$-bit & ${\sim}46$-bit & 1.27M & Low security (experiments only) \\
$n{=}128$ & ${\sim}203$-bit & ${\sim}98$-bit & 8.5M & Deployed parameter (production use) \\
\bottomrule
\end{tabular}
\caption{LBLO security estimates (modeled as uniform-secret LWE; $q{=}65521$, $m{=}2560$, no error term). Estimates based on dual attacks in the LWE Estimator~\cite{APS15}; \textbf{heuristic} since our construction lacks noise and standard LWE reductions do not apply. Gas costs are for 64-wire/640-gate circuits; only $n{=}128$ is used on-chain in \tlos{}.}
\end{table}

\textbf{Important caveat:} The estimates in Table~\ref{tab:lwe-security} are \emph{heuristic} because our construction lacks a Gaussian error term. Standard LWE security reductions do not apply directly. The quoted ``bit-security'' numbers should be interpreted as rough complexity yardsticks based on the best known attacks, not as formal security guarantees. We validated these estimates via direct lattice attacks using fpylll/BKZ; see \S\ref{sec:attack-validation}.

\subsection{Binary-Offset Hardness Analysis}
\label{sec:lblo}

Our construction is \emph{not} standard LWE. We call it ``Learning with Binary Large Offset'' (LBLO):

\begin{definition}[LBLO Problem]
\label{def:lblo}
The \emph{Learning with Binary Large Offset} problem LBLO$(n, q, m)$ is: given $m$ samples $(a_i, b_i)$ where $a_i \leftarrow \mathbb{Z}_q^n$ is uniform, $s \leftarrow \mathbb{Z}_q^n$ is a uniform secret, and
\[
b_i = \langle a_i, s \rangle + \mu_i \cdot (q/2) \mod q \quad \text{where } \mu_i \in \{0,1\}
\]
recover $s$ or any $\mu_i$ with non-negligible probability. The $\mu_i$ values are the hidden payload (control function bits in our application).
\end{definition}

\noindent LBLO differs from standard LWE in two critical ways: (1) the ``error'' term is exactly $0$ or $q/2$, not sampled from a small Gaussian; (2) the $\mu_i$ values (control function bits) are the hidden payload, not independent noise. We analyzed potential attack classes:

\textbf{Attack 1: Naive brute-force on all $\mu$.} An attacker could try all $2^m$ combinations of $\mu$ bits, checking consistency for each. For $m = 2560$ ciphertexts, this costs $2^{2560}$, completely infeasible. However, smarter attacks (Attack 5) reduce this to $2^n$.

\textbf{Attack 2: Lattice embedding.} Standard BDD/uSVP attacks embed $(s, e)$ as a short vector in a lattice. In our case, the ``error'' vector $e = \mu \cdot (q/2)$ has entries in $\{0, q/2\}$. Its norm is:
\[
\|e\| \approx \sqrt{m/2} \cdot (q/2) \approx \sqrt{1280} \cdot 32760 \approx 1.17 \times 10^6
\]
This is \emph{not} short relative to the lattice determinant. BDD attacks fail because the target is not close to a lattice point. We verified this empirically: BKZ-50 on $n{=}16$ instances with 200+ basis updates failed to recover $s$.

\textbf{Attack 3: Subset-sum / ISD.} View as finding $\mu \in \{0,1\}^m$ such that $b - \mu \cdot (q/2) = As$ is consistent. This resembles subset-sum with large modulus. For $m = 2560$, $n = 128$, the solution density is ${\sim}2^{-2432}$, far below the threshold for ISD attacks.

\textbf{Attack 4: Statistical distinguishing.} Observe that $b_i \mod (q/2) = \langle a_i, s \rangle \mod (q/2)$ regardless of $\mu_i$. For uniform $s \in \mathbb{Z}_q^n$, the distribution of $\langle a_i, s \rangle \mod (q/2)$ is statistically close to uniform over $\mathbb{Z}_{q/2}$. No distinguishing advantage.

\textbf{Attack 5: Algebraic attacks on subsets.} If an attacker could guess some $\mu_i$ values, they could set up partial linear equations. However, with 2560 unknowns and only 128-dimensional secret, even 128 correct guesses only yield one equation per guess; still $2^{128}$ combinations to try.

\textbf{Empirical Validation.} We implemented 9 attack classes in \texttt{scripts/lblo\_attack.py}:

\begin{table}[h]
\centering
\begin{tabular}{@{}llp{5cm}@{}}
\toprule
\textbf{Attack Class} & \textbf{Result} & \textbf{Details} \\
\midrule
Naive brute-force & FAIL & $2^{2560}$ (all $\mu$); infeasible \\
Statistical distinguishing & FAIL & $b$ uniform ($\chi^2 < 100$), no leakage \\
Lattice BDD/uSVP & FAIL & Error norm $1.17 \times 10^6 \gg$ Gaussian heuristic $19$ \\
Linear algebra & FAIL & Correct $\mu \to s$ recovered; wrong $\mu \to$ garbage \\
Subset guessing & FAIL & Still requires $2^n$ guesses per subset \\
Hybrid (guess $k$ bits) & FAIL & Must guess all $n$ bits; cost remains $2^n$ \\
Meet-in-the-middle & FAIL & Not applicable: $s$ shared across all equations \\
Actual BKZ-50 reduction & FAIL & Finds only trivial short vectors (norm 1) \\
$q/2$ structure exploit & FAIL & No parity leakage; requires knowing $s$ \\
\bottomrule
\end{tabular}
\caption{Summary of 9 attack classes tested against LBLO construction. All attacks fail.}
\end{table}

\textbf{Long-Running Exhaustive Validation.} We ran multi-hour exhaustive attacks on two servers to empirically measure attack scaling:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
$n$ & Rate (ops/s) & Full $2^n$ time & Extrapolated $n{=}128$ \\
\midrule
16 & 1,500 & 44 seconds & N/A \\
18 & 1,300 & 3.4 minutes & N/A \\
20 & 1,100 & 16 minutes & N/A \\
22 & 960 & 1.2 hours & N/A \\
24 & 820 & 5.7 hours & N/A \\
128 & (extrapolated) & N/A & $10^{28}$ years \\
\bottomrule
\end{tabular}
\caption{Exhaustive attack scaling (subset guessing). Here $n$ is the number of $\mu$ bits guessed per attempt. At ${\sim}1000$ ops/s, breaking $n{=}128$ requires $10^{28}$ years.}
\end{table}

\textbf{Parallelization.} The attack parallelizes trivially (each machine tries different $\mu$ subsets). However, even with $10^9$ parallel machines (all of Google's servers), $n{=}128$ still requires $10^{19}$ years. With $10^{18}$ machines (every atom a computer): $10^{10}$ years.

\begin{center}
\framebox{\parbox{0.9\textwidth}{
\textbf{Security Summary:} We tested 9 attack classes; all fail. Exhaustive search scales as $2^n$ with no shortcuts. Parallelization helps linearly but cannot overcome the exponential barrier. The ${\sim}2^{98}$ PQ / ${\sim}2^{203}$ classical estimates are empirically validated as conservative lower bounds. \emph{These are heuristic estimates, not formal security guarantees.}
}}
\end{center}

\subsection{Noiseless Variant: Attack Surface Analysis}
\label{sec:noiseless-attacks}

Our construction departs from standard LWE by omitting the Gaussian error term. This subsection explicitly analyzes the attack surface created by this design choice.

\textbf{What we lose without noise:}
\begin{enumerate}
  \item \textbf{Semantic security:} Standard LWE provides indistinguishability from uniform; our construction does not. Given $(a, b)$, an adversary can compute $b - \langle a, s \rangle \mod q$ for a \emph{known} $s$ and immediately recover $\mu$.
  
  \item \textbf{Reduction to lattice problems:} Standard LWE security reductions (to GapSVP, SIVP) rely on the error distribution. Our construction has no such reduction.
  
  \item \textbf{Sample amplification attacks:} Without noise, each sample provides a \emph{perfect} linear constraint on $(s, \mu)$. An adversary with unbounded samples could potentially exploit this structure.
\end{enumerate}

\textbf{Why security still holds (conditionally):}
\begin{enumerate}
  \item \textbf{Secret is unknown:} The adversary does \emph{not} know $s = H(\mathsf{secret})$. Recovering $\mu_i$ requires either knowing $s$ or solving a system with $2^m$ unknowns (the $\mu$ bits) and $n$-dimensional secret.
  
  \item \textbf{Large binary offset:} The ``error'' $\mu \cdot (q/2)$ is not small; it is either 0 or $q/2$. This breaks lattice BDD attacks which assume short error vectors.
  
  \item \textbf{Subset-guessing lower bound:} Our empirical analysis (\S\ref{sec:lblo}) shows that the best known attack requires guessing $n$ bits of the $\mu$ vector, costing $2^n$ work.
\end{enumerate}

\textbf{Potential novel attacks (open problems):}
\begin{itemize}
  \item \textbf{Algebraic structure exploitation:} The $q/2$ offset creates algebraic structure (parity over $\mathbb{Z}_q$). We tested for exploitable correlations and found none, but this remains an open research direction.
  
  \item \textbf{Multi-instance attacks:} If an adversary has access to multiple circuits encrypted under \emph{related} secrets, cross-circuit attacks may be possible. Our threat model assumes independent secrets.
  
  \item \textbf{Specialized lattice algorithms:} Our construction may be vulnerable to lattice algorithms tailored for binary offset rather than Gaussian noise. We are not aware of such algorithms, but their development would invalidate our security estimates.
\end{itemize}

\textbf{Limitations of our analysis:} Our experiments do not rule out:
\begin{itemize}
  \item Attacks exploiting joint structure across multiple LBLO instances (multi-target/multi-instance).
  \item Highly optimized bespoke lattice or algebraic techniques beyond BKZ-50.
  \item Attacks that combine information from the 1-bit on-chain oracle with the LBLO public data.
  \item Reductions from LBLO to a different, potentially easier hard problem.
\end{itemize}

\textbf{Call for independent analysis:} We encourage the cryptographic community to analyze the LBLO problem independently. Our attack suite is available at \texttt{scripts/lblo\_attack.py}; we welcome attempts to break it. We view the LBLO problem and our noiseless construction as \emph{experimental}. We do not recommend using current parameters for high-value, long-lived secrets until further independent cryptanalysis is available.

\subsection{Security Definitions}

\begin{definition}[Extraction Resistance]
An obfuscator $\obf$ is $(t, \varepsilon)$-extraction resistant if for all adversaries $\adv$ running in time $t$:
\[
\Pr[\adv(\obf(C)) \text{ outputs exploitable information about } C] \leq \varepsilon
\]
\end{definition}

\begin{definition}[Control-Function Hiding (Informal)]
\label{def:cf-hiding}
Let $\mathsf{Enc}_s(\mu) = (a, \langle a, s \rangle + \mu \cdot (q/2) \mod q)$ be our encoding scheme where $a \leftarrow \mathbb{Z}_q^n$ is uniform, $s \in \mathbb{Z}_q^n$ is the secret, and $\mu \in \{0,1\}$ is the control-function bit.

We say the encoding provides \emph{control-function hiding} if, for uniform $s$ unknown to the adversary:
\[
\Pr[\adv((a_1, b_1), \ldots, (a_m, b_m)) \text{ recovers any } \mu_i] \leq \mathsf{negl}(\lambda)
\]
where the probability is over the choice of $a_i$ and the adversary's coins.
\end{definition}

\begin{remark}[Relation to Standard LWE]
Definition~\ref{def:cf-hiding} captures what we need: an adversary cannot determine $\mu_i$ values without knowing $s$. This is \emph{weaker} than standard LWE semantic security (which requires indistinguishability from uniform). Our construction lacks noise, so LWE reductions do not apply. Instead, security relies on the empirical observation that recovering $s$ requires exhaustive search over $2^n$ subset guesses (see \S\ref{sec:lblo}). We explicitly do \emph{not} claim a reduction to standard LWE hardness.
\end{remark}

\begin{definition}[LBLO Control Function Security]
Control function encoding is secure if no \ppt{} adversary can recover CF bits from LBLO ciphertexts with non-negligible advantage under LBLO hardness (Definition~\ref{def:lblo}).
\end{definition}

\subsection{Assumptions}

\begin{assumption}[LBLO Hardness]
\label{asm:lblo}
The Learning with Binary Large Offset problem (Definition~\ref{def:lblo}) is computationally hard for the chosen parameters. This is a conjecture based on empirical analysis (\S\ref{sec:lblo}), not a reduction to standard LWE.
\end{assumption}

\begin{assumption}[Topology Empirical Security]
\label{asm:topology}
The topology layer's wire selection algorithm resists the structural and statistical attacks in our evaluation matrix. This is validated empirically via testing (no successful breaks found in 1000+ trials), not proven via formal reduction. Future attacks exploiting unanticipated structural patterns may exist.
\end{assumption}

\subsection{Main Theorem}

\begin{theorem}[\tlos{} Attack Resistance]
\label{thm:main}
Under Assumption~\ref{asm:lblo} (LBLO hardness), Assumption~\ref{asm:topology} (topology empirical security), and the wrong-key-gives-garbage property (1-bit on-chain oracle with no subcircuit access), \tlos{} achieves extraction resistance against our 9-class attack matrix.
\end{theorem}

\begin{proof}
We consider each attack class:

\textbf{Structural attacks (3/6):} Compression, PatternMatch, and Structural (Butterfly) attacks rely on detecting patterns in wire selection. The topology layer uses non-pow2 distances and random CF cycling, which \emph{no known attack in our suite successfully exploits}. \emph{Empirically validated} (Assumption~\ref{asm:topology}), but we cannot prove that more sophisticated structural attacks do not exist.

\textbf{Statistical attacks:} Statistical (Chi-squared) and DiagonalCorrelation attacks rely on non-uniform wire usage and input-output correlation. The topology layer enforces uniform wire usage and uses 64+ wires with irregular layers, which \emph{our implemented attacks fail to exploit}. \emph{Empirically validated} (Assumption~\ref{asm:topology}) against our test distributions.

\textbf{Semantic attacks:} RainbowTable requires subcircuit evaluation. The LBLO layer hides control functions via ciphertexts with on-chain inner products. Recovering CFs requires solving LBLO (Assumption~\ref{asm:lblo}).

Therefore, no attack in our 9-class evaluation matrix successfully extracts secrets under the stated assumptions. \emph{This should be read as ``no break found in our test suite,'' not ``secure against all possible attacks.'' We cannot rule out future attack vectors that exploit structural or statistical properties we have not tested.}
\end{proof}

\subsection{Post-Quantum Security}

\begin{proposition}[\tlos{} Post-Quantum Security (Conjectured)]
\tlos{} is conjectured to be post-quantum secure assuming LBLO is quantum-resistant.
\end{proposition}

\begin{proof}
The topology layer uses no cryptographic primitives; it is purely structural and unaffected by quantum computers.

The LBLO layer is modeled after LWE, which is believed quantum-resistant and forms the basis of NIST post-quantum standards~\cite{FIPS203}. However, since LBLO is noiseless and lacks a formal reduction to standard LWE, post-quantum resistance is conjectured based on the absence of known quantum attacks, not proven.

Therefore, \tlos{} is conjectured to inherit the quantum resistance of LWE-style constructions, subject to the LBLO hardness assumption.
\end{proof}



\subsection{Oracle Model Considerations}

In the oracle model, the attacker can query the circuit on chosen inputs.

\begin{observation}
For predicate circuits with $n$-bit inputs and 1-bit output, brute-force requires $2^n$ queries.
\end{observation}

For honeypots with 256-bit secrets, brute-force is infeasible. The binary output limits information leakage: each query reveals only one bit, and the output is independent of all inputs except the secret.

\begin{observation}[Oracle Attack Cost]
For predicates $P(x) = [f(x) = s]$ where $s$ has min-entropy $k$ bits, classical oracle-based search requires $\Theta(2^k)$ queries. Quantum search (Grover) reduces this to $\Theta(2^{k/2})$ queries.
\end{observation}

For honeypots with 256-bit secrets, even quantum brute-force is infeasible ($2^{128}$ queries).

\subsection{Oracle Leakage Analysis}
\label{sec:oracle-leakage}

We now provide a more formal analysis of information leakage through the 1-bit on-chain oracle interface.

\textbf{Oracle interface:} The on-chain contract exposes a single function \texttt{check(x)} that returns 1 if $x = \mathsf{secret}$ and 0 otherwise. Let $\mathcal{O}$ denote this oracle.

\textbf{Information-theoretic bound:} For a secret $s$ with min-entropy $k$ bits, each oracle query $\mathcal{O}(x)$ reveals at most 1 bit of information about $s$. In the worst case, an adaptive adversary making $q$ queries learns at most $q$ bits.

\textbf{Shannon entropy analysis:} Let $H(S)$ denote the entropy of the secret distribution. After $q$ queries $\{x_1, \ldots, x_q\}$ with responses $\{r_1, \ldots, r_q\}$, the conditional entropy satisfies:
\[
H(S \mid r_1, \ldots, r_q) \geq H(S) - q
\]
For uniformly random $k$-bit secrets, $H(S) = k$, so the adversary must make at least $k$ queries to fully determine $s$ (information-theoretically).

\textbf{Practical leakage:} For point functions $P(x) = [x = s]$ where $s$ is uniformly distributed over a domain of size $2^k$:
\begin{itemize}
  \item Each \emph{negative} response ($\mathcal{O}(x_i) = 0$) rules out exactly one candidate: $s \neq x_i$
  \item Expected queries to find $s$ via random search: $\Theta(2^k)$
  \item Best-case adaptive strategy (if structure is known): still $\Theta(2^k)$ for uniformly random $s$
\end{itemize}

\textbf{Comparison with multi-bit oracles:} If the oracle returned intermediate wire states or multi-bit outputs, leakage would be dramatically higher. For example, an oracle returning the Hamming distance $|x \oplus s|$ would enable binary search, reducing attack cost from $\Theta(2^k)$ to $\Theta(k)$ queries.

\textbf{Side-channel considerations (out of scope):} Our analysis assumes the oracle leaks \emph{only} the 1-bit output. In practice, EVM-level side channels (gas usage, storage access patterns, timing) may leak additional information. Mitigating these is outside the scope of \tlos{} and would require:
\begin{itemize}
  \item Constant-time/constant-gas implementations (challenging in EVM)
  \item Oblivious RAM-style storage access (prohibitively expensive)
  \item Differential privacy techniques (not applicable to deterministic predicates)
\end{itemize}

\textbf{Open problem:} A fully formal leakage analysis would model the adversary's knowledge as a probability distribution over the secret space and quantify how oracle responses update this distribution. For uniform secrets and memoryless oracles, the 1-bit bound is tight. For structured secrets or stateful adversaries (e.g., learning the circuit structure over many queries), tighter bounds may be possible. We leave this to future work and welcome formal analysis by the cryptographic community.

%------------------------------------------------------------------------------
\section{Gas Costs and Deployment}
%------------------------------------------------------------------------------

\subsection{Gas Estimates}

\begin{table}[h]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{\lwe{} Dimension} & \textbf{Security (Classical)} & \textbf{Gas} & \textbf{Block \%} \\
\midrule
$n{=}16$ & ${\sim}22$-bit & 744K & 2.5\% \\
$n{=}32$ & ${\sim}51$-bit & 1.27M & 4.2\% \\
\textbf{$n{=}128$} & \textbf{${\sim}203$-bit} & \textbf{8.5M} & \textbf{28\%} \\
\bottomrule
\end{tabular}
\caption{\tlos{} gas costs by \lwe{} dimension (64-wire/640-gate circuits, Tenderly-confirmed). Security estimates for uniform-secret \lwe{} (dual attack).}
\end{table}

\textbf{Storage:} Circuit data is stored via SSTORE2 (code-as-storage):
\begin{itemize}
  \item $n{=}16$: 89 KB
  \item $n{=}32$: 171 KB
  \item $n{=}128$: 662 KB
\end{itemize}

For the paper, we use $n{=}128$ providing ${\sim}203$-bit classical/${\sim}98$-bit post-quantum security, suitable for production applications.

%------------------------------------------------------------------------------
\section{Attack Evaluation}
%------------------------------------------------------------------------------

We empirically validated \tlos{} against 14 attack implementations across 6 categories.

\begin{table}[h]
\centering
\small
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Attack} & \textbf{Type} & \textbf{Defense} & \textbf{Status} \\
\midrule
\multicolumn{4}{l}{\textit{Structural Attacks (Defeated by Topology Layer)}} \\
Compression & Structural & Topology & \textsc{Blocked} \\
PatternMatch & Structural & Topology & \textsc{Blocked} \\
Structural (Butterfly) & Structural & Topology & \textsc{Blocked} \\
\midrule
\multicolumn{4}{l}{\textit{Statistical Attacks (Defeated by Wire Selection)}} \\
Statistical (Chi-squared) & Statistical & Topology & \textsc{Blocked} \\
DiagonalCorrelation & Statistical & Topology & \textsc{Blocked} \\
\midrule
\multicolumn{4}{l}{\textit{Semantic Attacks (Blocked by LBLO Layer)}} \\
RainbowTable & Semantic & LBLO & \textsc{Blocked} \\
\midrule
\multicolumn{4}{l}{\textit{Advanced Attacks (Mitigated by Binary Output)}} \\
SAT/Key Recovery & Algebraic & Binary output & \textsc{Mitigated} \\
Oracle-Guided Synthesis & Learning & Binary output & \textsc{Mitigated} \\
CEGIS & Synthesis & Binary output & \textsc{Mitigated} \\
\bottomrule
\end{tabular}
\caption{Attack evaluation matrix. This is our evaluation taxonomy, not a universal security measure.}
\end{table}

\textbf{SAT/CEGIS results:} On 64-wire/640-gate circuits, off-the-shelf SAT solvers (MiniSat, CryptoMiniSat) timed out after 24 hours. This is empirical evidence, not a hardness proof.

\textbf{Important caveat:} These results validate that \tlos{} defeats \emph{our specific attack implementations} under \emph{our test distributions}. They should not be interpreted as a general guarantee against all possible attacks. Publishing the full attack suite enables independent verification and discovery of new attack vectors.

\subsection{Lattice Attack Validation}
\label{sec:attack-validation}

To validate our security estimates, we implemented direct lattice attacks against \tlos{} instances using fpylll~\cite{fpylll}:

\textbf{Experimental setup:}
\begin{itemize}
  \item Generated \tlos{} \lwe{} instances with uniform secrets: $s = H(\mathsf{secret}) \in \mathbb{Z}_q^n$
  \item Built Kannan embedding lattices for BKZ reduction
  \item Ran BKZ with progressive block sizes ($\beta = 20, 30, 40, 50$)
  \item Measured success rate and running time
\end{itemize}

\textbf{Results:}
\begin{itemize}
  \item \textbf{$n{=}16$:} BKZ-50 with 200+ basis updates \emph{failed} to recover the secret. Primal attack ineffective due to large secret norm ($\|s\| \approx \sqrt{n} \cdot q/2$).
  \item \textbf{$n{=}128$:} Attack infeasible with current hardware. BKZ reduction would require block sizes $\beta > 300$, estimated at $2^{100}+$ core-hours. Validates ${\sim}203$-bit security estimate.
\end{itemize}

\textbf{Key finding:} The uniform-secret variant of \lwe{} used in \tlos{} is harder to attack than small-secret \lwe{}. Standard primal (uSVP) attacks assume the secret has small norm; when $s$ is uniform, these attacks fail. Dual attacks remain applicable but require larger BKZ block sizes.

\textbf{Reproducibility:} Attack code is available at \url{https://github.com/igor53627/tlos} (scripts/lblo\_attack.py).

\subsection{Layer Ablation}

We evaluated attack resistance with different layer combinations to understand each layer's contribution:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Configuration} & \textbf{Structural (3)} & \textbf{Statistical (2)} & \textbf{Semantic (1)} & \textbf{Mix-Match (1)} \\
\midrule
Baseline (no obfuscation) & 0/3 & 0/2 & 0/1 & 0/1 \\
Topology only & 3/3 & 2/2 & 0/1 & 0/1 \\
Topology + LBLO & 3/3 & 2/2 & 1/1 & 0/1 \\
Topology + LBLO + Wire Binding (\tlos{}) & 3/3 & 2/2 & 1/1 & 1/1 \\
\bottomrule
\end{tabular}
\caption{Layer ablation: attacks defeated per category. Numbers in parentheses indicate total attacks in category.}
\label{tab:ablation}
\end{table}

\textbf{Key findings:}
\begin{itemize}
  \item \textbf{Topology alone} defeats structural attacks (compression, pattern matching, butterfly detection) and statistical attacks (chi-squared, diagonal correlation), but \emph{not} semantic attacks.
  \item \textbf{LBLO layer} is necessary to defeat semantic attacks (RainbowTable). Without LBLO-hidden control functions, an attacker can evaluate subcircuits and match against known truth tables.
  \item \textbf{Wire binding layer} is necessary to prevent mix-and-match attacks. Without wire binding, an attacker can evaluate gates with inconsistent wire values from different execution paths.
\end{itemize}

%------------------------------------------------------------------------------
\section{Implementation}
%------------------------------------------------------------------------------

\subsection{Smart Contract Architecture}

\tlos{} requires no external infrastructure; just a standard smart contract. We illustrate with an NFT mystery box example where trait generation logic is hidden:

\begin{lstlisting}[caption=TLOSKitties Contract (simplified)]
contract TLOSKitties is ERC721 {
    bytes public circuitData;  // Obfuscated trait generator
    uint256 public totalMinted;
    
    struct Traits {
        uint8 fur;      // 0-15: common to legendary
        uint8 eyes;     // 0-7: patterns
        uint8 accessory; // 0-31: items
        uint8 background; // 0-7: colors
    }
    mapping(uint256 => Traits) public kittyTraits;
    
    function mint() external payable returns (uint256) {
        uint256 tokenId = ++totalMinted;
        // Entropy from blockhash + minter + tokenId
        bytes32 entropy = keccak256(abi.encode(
            blockhash(block.number - 1), msg.sender, tokenId
        ));
        // TLOS circuit maps entropy -> traits (logic hidden)
        uint256 output = evaluateTLOS(entropy);
        kittyTraits[tokenId] = decodeTraits(output);
        _mint(msg.sender, tokenId);
        return tokenId;
    }
    
    function decodeTraits(uint256 output) internal pure 
        returns (Traits memory) {
        return Traits(
            uint8(output & 0xF),        // fur: 4 bits
            uint8((output >> 4) & 0x7), // eyes: 3 bits
            uint8((output >> 7) & 0x1F),// accessory: 5 bits
            uint8((output >> 12) & 0x7) // background: 3 bits
        );
    }
}
\end{lstlisting}

\textbf{Why TLOS here?} With visible trait logic, minters could simulate which \texttt{(blockhash, sender, tokenId)} combinations yield rare traits and time their mints accordingly. TLOS hides the mapping: the circuit is deterministic and verifiable, but attackers cannot predict which inputs produce legendary fur.

\subsection{Gas Costs}

\begin{table}[h]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Variant} & \textbf{Operation} & \textbf{Gas ($n{=}128$)} & \textbf{\% of 30M} \\
\midrule
\tlos{} & \texttt{check()} & 8.5M & 28\% \\
\midrule
All & \texttt{commit()} & 47K & 0.16\% \\
All & \texttt{reveal()} & varies & varies \\
\bottomrule
\end{tabular}
\caption{Gas costs on 64-wire/640-gate circuits with $n{=}128$ \lwe{} dimension. Tenderly-measured.}
\end{table}

\subsection{Commit-Reveal Protocol}

To prevent front-running:
\begin{enumerate}
  \item \textbf{Commit:} User submits $H = \mathsf{hash}(\mathsf{sender} \| \mathsf{secret})$
  \item \textbf{Wait:} $k \geq 1$ blocks
  \item \textbf{Reveal:} User submits secret; contract verifies $H$ matches
\end{enumerate}

Sender binding prevents reward theft: an attacker copying the reveal transaction computes $\mathsf{hash}(\mathsf{attacker} \| \mathsf{secret}) \neq H$.

%------------------------------------------------------------------------------
\section{Wire Binding: Inter-Gate Consistency}
\label{sec:wire-binding}
%------------------------------------------------------------------------------

\tlos{} includes a full-rank linear hash (inspired by~\cite{MDS25}, but \emph{not} subspace-evasive in the formal sense) that binds wire values across gate evaluations, preventing mix-and-match attacks.

\subsection{The Mix-and-Match Attack}

Without wire binding, gates are evaluated independently. An attacker could potentially:
\begin{enumerate}
  \item Evaluate gate $i$ with crafted inputs $(w_1, w_2)$
  \item Evaluate gate $j$ with \emph{different} crafted inputs $(w'_1, w'_2)$
  \item Combine outputs to learn about circuit structure
\end{enumerate}

This is a \emph{mix-and-match attack}: using inconsistent intermediate values to probe the circuit.

\subsection{Wire Binding Construction}

The wire binding layer uses a full-rank linear map over $\mathbb{Z}_q$: $H_k(x) = A_k x \mod q$ where $A_k \in \mathbb{Z}_q^{64 \times 64}$ is derived from the circuit seed and batch index $k$. Each 128-gate batch updates the accumulator:
\[
\mathsf{acc}_{k+1} = H_k(\mathsf{acc}_k + \mathsf{wires}_k \mod q)
\]
where $\mathsf{wires}_k$ is the packed wire state after batch $k$, and addition is component-wise over $\mathbb{Z}_q^{64}$.

\textbf{Why 64$\times$64?} A full-rank matrix has trivial kernel (only zero vector), so $H$ is a bijection: each accumulator value has a unique preimage. Smaller matrices have large nullspaces where many wire states collide.

\textbf{Clarification:} This is a \emph{public} linear map (no secret, no noise). It provides \emph{algebraic binding}, not cryptographic hiding or collision resistance. The linear system $Ax = y$ is trivially solvable; the security property is that forged wire values produce a different accumulator that cannot be ``repaired'' without recomputing a full consistent trace.

\subsection{Security Properties}

\textbf{What wire binding provides:}
\begin{itemize}
  \item Mix-and-match prevention: Gates cannot be evaluated with inconsistent inputs
  \item Execution trace binding: Full evaluation history is committed to a 1024-bit accumulator
  \item Algebraic binding: For full-rank $A$, each accumulator has unique preimage
\end{itemize}

\textbf{What wire binding does NOT provide:}
\begin{itemize}
  \item Cryptographic hiding: The linear map is public and invertible
  \item Collision resistance: Trivial to find $x$ given $Ax = y$
  \item Key extraction resistance: Still relies on the LBLO layer for control function hiding
\end{itemize}

\subsection{Hybrid Security Model}

The full \tlos{} system has three security components:
\begin{itemize}
  \item \textbf{LWE} for control function hiding (${\sim}98$-bit post-quantum for $n{=}128$)
  \item \textbf{Wire binding} for wire consistency (algebraic binding)
  \item \textbf{Hash preimage} for unlocking (${\sim}256$-bit)
\end{itemize}

The weakest link determines overall security. LWE provides computational hardness; wire binding provides integrity/binding.

%------------------------------------------------------------------------------
\section{Comparison with Hash-Compare Baseline}
\label{sec:hash-compare}
%------------------------------------------------------------------------------

A natural question is: why not just use a simple hash comparison?

\textbf{Hash-Compare Baseline:} For a simple predicate $P(x) = [x = \mathsf{secret}]$, one could deploy:
\begin{lstlisting}
function check(bytes32 x) returns (bool) {
    return keccak256(x) == storedHash;
}
\end{lstlisting}

This costs ${\sim}50$K gas and provides 256-bit preimage resistance. Why use \tlos{}'s 8.5M gas for ${\sim}98$-bit \lwe{} security?

\subsection{When Hash-Compare Suffices}

For simple ``guess the secret'' predicates, \textbf{hash-compare is equivalent or better}:
\begin{itemize}
  \item Lower gas (${\sim}50$K vs 8.5M)
  \item Higher security (256-bit vs 98-bit PQ)
  \item Simpler implementation
\end{itemize}

\textbf{Use hash-compare} when: the predicate is $P(x) = [x = \mathsf{secret}]$ and revealing the \emph{structure} of the check (``it's a hash comparison'') is acceptable.

\subsection{When \tlos{} Adds Value}

\tlos{} provides value beyond hash-compare in scenarios where:

\begin{enumerate}
  \item \textbf{Predicate structure is sensitive:} If the attacker learning ``it's a simple hash check'' vs ``it's a complex multi-condition check'' is itself a vulnerability, \tlos{} hides this structure.
  
  \item \textbf{Complex predicates:} For predicates like $P(x) = [f(x) \in S]$ where $f$ is a non-trivial function (price thresholds, multi-party conditions, range checks), the predicate structure itself may reveal exploitable information.
  
  \item \textbf{Partial information leakage:} Hash-compare reveals nothing about wrong inputs. But for complex predicates, different wrong inputs might behave differently; \tlos{}'s wrong-key garbage property ensures all wrong inputs look equally random.
  
  \item \textbf{Composable obfuscation:} \tlos{} circuits can be composed. Multiple predicates can share structure without revealing which checks are related.
\end{enumerate}

\subsection{Multi-Bit Output: The Key Distinction}

A critical difference between hash-compare and \tlos{} is the \emph{output dimensionality}:

\begin{center}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Approach} & \textbf{Output} & \textbf{What's Hidden} \\
\midrule
Hash-compare & 1 bit (true/false) & Secret value only \\
\tlos{} circuit & $N$ bits (multi-bit) & Secret value + hidden computation \\
\bottomrule
\end{tabular}
\end{center}

\textbf{Hash-compare} returns only a boolean: ``does your input match the secret?'' The output conveys no information beyond this binary answer.

\textbf{\tlos{} circuits compute a function.} When the correct input is provided, the circuit evaluates to a multi-bit output that can encode:
\begin{itemize}
  \item Hidden parameters (e.g., threshold offsets, multipliers)
  \item Computed results (e.g., PID controller outputs)
  \item Encoded payloads (revealed only on correct input)
\end{itemize}

\textbf{Example: Hidden Parameter Extraction.} Consider a DeFi application where the liquidation threshold is obfuscated:
\begin{lstlisting}
// Hash-compare: only confirms match
function check(bytes32 x) returns (bool) {
    return keccak256(x) == storedHash;  // 1-bit output
}

// TLOS: extracts hidden parameter on match
function extractThreshold(bytes32 x) returns (int256) {
    uint256 output = evaluateTLOS(x);
    if (output == GARBAGE) revert();    // wrong key
    // 8-bit output -> threshold offset (-20% to +20%)
    int256 offset = int256(output & 0xFF) - 128;
    return baseThreshold + (offset * baseThreshold / 128);
}
\end{lstlisting}

The circuit output encodes a hidden computation result, not just a match/no-match signal.

\subsection{Point Function with Hidden Payload}

Both hash-compare and \tlos{} implement \emph{point functions}: predicates that evaluate meaningfully only at $x = \mathsf{secret}$. The distinction is:
\begin{itemize}
  \item \textbf{Hash-compare:} Point function with 1-bit output (``yes, you found it'')
  \item \textbf{\tlos{}:} Point function with $N$-bit output (``here's the hidden result'')
\end{itemize}

For applications where the \emph{payload} matters (not just the confirmation), \tlos{} provides value that hash-compare cannot. The ${\sim}170\times$ gas premium buys multi-bit hidden computation, not stronger unlocking security.

\subsection{Honest Assessment}

For most honeypot use cases (``find the 256-bit secret''), hash-compare is the right choice. \tlos{}'s value is in:
\begin{itemize}
  \item \textbf{Multi-bit hidden output:} Revealing computed results, not just confirmation
  \item Hiding predicate \emph{complexity} (is it one condition or ten?)
  \item Hiding predicate \emph{structure} (which variables matter?)
  \item Providing a general framework for obfuscating arbitrary circuits (not just point functions)
\end{itemize}

We do not claim \tlos{} is always better than hash-compare. The choice depends on the application's threat model and whether multi-bit hidden output is required.

%------------------------------------------------------------------------------
\section{Limitations and Open Problems}
%------------------------------------------------------------------------------

\subsection{Theoretical Gaps}

\begin{enumerate}
  \item \textbf{Topology security is empirical:} We validate against our 9-class attack suite but cannot prove no faster attack exists. Future attacks may defeat the topology layer.
  
  \item \textbf{No iO guarantee:} We do not prove indistinguishability of obfuscations of equivalent circuits. \tlos{} obfuscations may be distinguishable.
  
  \item \textbf{Binary output assumption:} Security analysis assumes 1-bit output. Security degrades for circuits with multi-bit outputs or richer oracle interfaces.
\end{enumerate}

\subsection{Practical Concerns}

\begin{enumerate}
  \item \textbf{Gas costs:} \tlos{} with $n{=}128$ \lwe{} requires ${\sim}8.5$M gas (28\% of block limit). This is practical for high-value, infrequent operations.
  
  \item \textbf{Storage:} Circuit data requires 662 KB (SSTORE2) for $n{=}128$. Deployment costs are dominated by SSTORE2 writes.
  
  \item \textbf{Circuit size:} Larger circuits provide better security but higher gas costs. The 64-wire/640-gate configuration is a trade-off.
  
  \item \textbf{Expiry management:} Setting appropriate expiry timestamps requires application-specific knowledge.
  
  \item \textbf{EVM side channels:} Gas timing, storage access patterns, and other EVM-level side channels are out of scope.
\end{enumerate}

\subsection{What \tlos{} Does NOT Provide}

\begin{enumerate}
  \item \textbf{iO Security:} Obfuscations of equivalent circuits are not indistinguishable.
  
  \item \textbf{Forward Secrecy:} Expired secrets may be analyzed retroactively.
  
  \item \textbf{VBB Security:} Virtual black-box is impossible in general~\cite{BGI12}.
  
  \item \textbf{Universal Security:} We resist our 9-class taxonomy, not all possible attacks.
\end{enumerate}

%------------------------------------------------------------------------------
\section{Conclusion}
%------------------------------------------------------------------------------

\tlos{} provides practical circuit obfuscation for smart contracts through three-layer defense:

\begin{itemize}
  \item \textbf{Topology layer (heuristic):} Defeats structural and statistical attacks through wire selection patterns. Empirically validated.
  \item \textbf{LBLO layer (heuristic):} On-chain inner product computation hides control functions, defeating semantic attacks. \emph{Estimated} ${\sim}2^{98}$ post-quantum cost for known attacks with $n{=}128$; this is a heuristic estimate based on the LBLO problem (\S\ref{sec:lblo}), not a reduction to standard LWE.
  \item \textbf{Wire binding layer:} Full-rank linear hash (inspired by~\cite{MDS25}) binds wire values across gates, preventing mix-and-match attacks. Security: algebraic binding.
\end{itemize}

\tlos{} achieves 9/9 resistance against our attack evaluation matrix at ${\sim}8.5$M gas with $n{=}128$ and 64 wires/640 gates. Security is based on conjectured LBLO hardness; the wire binding layer provides algebraic consistency. The system targets \emph{eventually-expiring secrets} where post-quantum security is desired.

\textbf{Key contributions:}
\begin{itemize}
  \item On-chain LBLO (LWE-like) inner products for control function hiding
  \item Wrong-key garbage property: attackers can simulate offline but learn nothing without the correct secret
  \item Wire binding: inter-gate consistency prevents mix-and-match attacks
  \item Practical gas costs within EVM block limits
  \item Honest comparison with hash-compare baseline (Section~\ref{sec:hash-compare})
\end{itemize}

\textbf{Limitations:} Topology security is heuristic, not proven. LBLO security is conjectured based on empirical attack analysis, not proven via reduction to standard assumptions. Gas costs (${\sim}8.5$M) may be prohibitive for frequent operations. We do not recommend current parameters for high-value, long-lived secrets until further independent cryptanalysis validates the LBLO hardness conjecture.

\textbf{Future Work:}
\begin{itemize}
  \item Per-gate wire binding updates for stronger consistency
  \item Formal analysis of topology layer security
  \item Higher security parameters ($n \geq 256$) for NIST-level PQ security
\end{itemize}

%------------------------------------------------------------------------------
\bibliographystyle{abbrv}
\bibliography{refs}

%------------------------------------------------------------------------------
\appendix

\section{Wire Selection Implementation}

\begin{lstlisting}[caption=Wire Selection (Rust)]
fn select_wires(
    gate_idx: usize,
    num_wires: usize,
    usage: &mut [u32],
    rng: &mut impl Rng,
) -> (usize, usize, usize) {
    // Select active wire (prefer underused)
    let active = (0..num_wires)
        .min_by_key(|&w| usage[w])
        .unwrap();
    
    // Non-pow2 distances
    let non_pow2: Vec<usize> = (3..num_wires/2)
        .filter(|d| !d.is_power_of_two())
        .collect();
    
    let d1 = *non_pow2.choose(rng).unwrap();
    let d2 = *non_pow2.iter()
        .filter(|&&d| d != d1)
        .choose(rng).unwrap();
    
    let c1 = (active + d1) % num_wires;
    let c2 = (active + d2) % num_wires;
    
    // Update usage
    usage[active] += 2;
    usage[c1] += 1;
    usage[c2] += 1;
    
    (active, c1, c2)
}
\end{lstlisting}

\section{Empirical Attack Results}

Validation on 1000 random circuits ($w=64$ wires, $g=640$ gates) using our implemented attack suite:

\begin{table}[h]
\centering
\begin{tabular}{@{}lc@{}}
\toprule
\textbf{Attack} & \textbf{\tlos{} ($n{=}128$)} \\
\midrule
Compression & 0\% \\
PatternMatch & 0\% \\
Structural & 0\% \\
Statistical & 0\% \\
DiagonalCorrelation & 0\% \\
RainbowTable & 0\% \\
\bottomrule
\end{tabular}
\caption{Attack success rates within our implemented attack suite. 0\% indicates no successful extraction across 1000 trials; this is empirical evidence, not a formal security proof.}
\end{table}

\end{document}
