//! SixSix Pattern Detector - Attack #7
//!
//! Attempts to detect circuits generated by our SixSix construction.
//! If this succeeds, our "obfuscation" is broken.

use crate::attacks::AttackResult;
use crate::circuit::Circuit;

/// Detect SixSix-specific patterns
pub struct SixSixDetector;

impl SixSixDetector {
    /// Run all SixSix detection heuristics
    pub fn detect(circuit: &Circuit) -> SixSixDetectionResult {
        let pow2_avoidance = Self::detect_pow2_avoidance(circuit);
        let perfect_uniformity = Self::detect_perfect_uniformity(circuit);
        let bimodal_layers = Self::detect_bimodal_layers(circuit);
        let cf_cycling = Self::detect_cf_cycling(circuit);
        let underused_preference = Self::detect_underused_preference(circuit);

        let signals = vec![
            ("Pow2Avoidance", pow2_avoidance),
            ("PerfectUniformity", perfect_uniformity),
            ("BimodalLayers", bimodal_layers),
            ("CFCycling", cf_cycling),
            ("UnderusedPreference", underused_preference),
        ];

        let detected_count = signals.iter().filter(|(_, s)| s.detected).count();
        let confidence =
            signals.iter().map(|(_, s)| s.confidence).sum::<f64>() / signals.len() as f64;

        SixSixDetectionResult {
            is_sixsix: detected_count >= 3,
            detected_count,
            total_signals: signals.len(),
            confidence,
            signals,
        }
    }

    /// Detect avoidance of power-of-2 distances
    /// SixSix specifically uses non_pow2 distances
    fn detect_pow2_avoidance(circuit: &Circuit) -> DetectionSignal {
        if circuit.gates.is_empty() {
            return DetectionSignal::none("Empty circuit");
        }

        let mut pow2_count = 0;
        let mut total_distances = 0;

        for gate in &circuit.gates {
            let active = gate.pins[0] as usize;
            for &ctrl in &gate.pins[1..] {
                let dist = active.abs_diff(ctrl as usize);
                if dist > 0 {
                    total_distances += 1;
                    if dist.is_power_of_two() {
                        pow2_count += 1;
                    }
                }
            }
        }

        if total_distances == 0 {
            return DetectionSignal::none("No distances");
        }

        let pow2_ratio = pow2_count as f64 / total_distances as f64;

        // In random circuit with n wires, ~log2(n)/n distances are pow2
        // For 64 wires: ~6/64 = 9.4% expected
        // For 256 wires: ~8/256 = 3.1% expected
        // SixSix: ~0% (we explicitly avoid pow2)

        let expected_pow2_ratio = (circuit.num_wires as f64).log2() / circuit.num_wires as f64;

        // If pow2 ratio is much LOWER than expected, it's SixSix
        let avoidance_score = if pow2_ratio < expected_pow2_ratio * 0.3 {
            1.0 - (pow2_ratio / expected_pow2_ratio)
        } else {
            0.0
        };

        DetectionSignal {
            detected: pow2_ratio < expected_pow2_ratio * 0.3,
            confidence: avoidance_score,
            details: format!(
                "Pow2 ratio: {:.1}% (expected ~{:.1}%, avoidance: {:.2})",
                pow2_ratio * 100.0,
                expected_pow2_ratio * 100.0,
                avoidance_score
            ),
        }
    }

    /// Detect suspiciously perfect wire usage uniformity
    /// SixSix explicitly targets uniform distribution
    fn detect_perfect_uniformity(circuit: &Circuit) -> DetectionSignal {
        if circuit.gates.is_empty() {
            return DetectionSignal::none("Empty circuit");
        }

        let mut wire_counts = vec![0usize; circuit.num_wires];
        for gate in &circuit.gates {
            for &pin in &gate.pins {
                if (pin as usize) < circuit.num_wires {
                    wire_counts[pin as usize] += 1;
                }
            }
        }

        let total: usize = wire_counts.iter().sum();
        let expected = total as f64 / circuit.num_wires as f64;

        let chi_squared: f64 = wire_counts
            .iter()
            .map(|&obs| {
                let diff = obs as f64 - expected;
                diff * diff / expected
            })
            .sum();

        let df = (circuit.num_wires - 1) as f64;
        let normalized_chi = chi_squared / df;

        // Random circuit: chi-squared/df varies widely (0.5 to 3.0+)
        // SixSix: chi-squared/df is very close to 1.0 (perfect uniformity)

        let too_perfect = normalized_chi > 0.7 && normalized_chi < 1.3;
        let perfectness = 1.0 - (normalized_chi - 1.0).abs();

        DetectionSignal {
            detected: too_perfect && perfectness > 0.8,
            confidence: if too_perfect { perfectness } else { 0.0 },
            details: format!(
                "Chi-squared/df: {:.3} (perfect=1.0, perfectness: {:.2})",
                normalized_chi, perfectness
            ),
        }
    }

    /// Detect bimodal layer size distribution
    /// SixSix uses small (1-5) and large (30-70) layers
    fn detect_bimodal_layers(circuit: &Circuit) -> DetectionSignal {
        if circuit.gates.len() < 10 {
            return DetectionSignal::none("Too few gates");
        }

        let mut layer_sizes = Vec::new();
        let mut current_layer_start = 0;
        let mut used_in_layer: std::collections::HashSet<u8> = std::collections::HashSet::new();

        for (idx, gate) in circuit.gates.iter().enumerate() {
            if used_in_layer.contains(&gate.pins[0]) {
                if idx > current_layer_start {
                    layer_sizes.push(idx - current_layer_start);
                }
                current_layer_start = idx;
                used_in_layer.clear();
            }
            used_in_layer.insert(gate.pins[0]);
        }

        if circuit.gates.len() > current_layer_start {
            layer_sizes.push(circuit.gates.len() - current_layer_start);
        }

        if layer_sizes.len() < 5 {
            return DetectionSignal::none("Too few layers");
        }

        // Check for bimodal distribution (small: 1-5, large: 30+)
        let small_layers = layer_sizes.iter().filter(|&&s| s <= 5).count();
        let large_layers = layer_sizes.iter().filter(|&&s| s >= 30).count();
        let medium_layers = layer_sizes.iter().filter(|&&s| s > 5 && s < 30).count();

        let total = layer_sizes.len();
        let small_ratio = small_layers as f64 / total as f64;
        let large_ratio = large_layers as f64 / total as f64;
        let medium_ratio = medium_layers as f64 / total as f64;

        // SixSix: ~70% small, ~30% large, ~0% medium
        // Random: more uniform distribution

        let bimodal_score = if medium_ratio < 0.2 && small_ratio > 0.5 && large_ratio > 0.1 {
            (small_ratio + large_ratio) / 2.0
        } else {
            0.0
        };

        DetectionSignal {
            detected: bimodal_score > 0.5,
            confidence: bimodal_score,
            details: format!(
                "Layer distribution: {:.0}% small, {:.0}% large, {:.0}% medium (bimodal: {:.2})",
                small_ratio * 100.0,
                large_ratio * 100.0,
                medium_ratio * 100.0,
                bimodal_score
            ),
        }
    }

    /// Detect sequential control function cycling
    /// SixSix uses: cf_idx = (cf_idx + 1) % nontrivial.len()
    fn detect_cf_cycling(circuit: &Circuit) -> DetectionSignal {
        if circuit.gates.len() < 20 {
            return DetectionSignal::none("Too few gates");
        }

        // Check for sequential CF pattern
        let cfs: Vec<u8> = circuit
            .gates
            .iter()
            .map(|g| g.control_function as u8)
            .collect();

        let mut sequential_pairs = 0;
        let mut total_pairs = 0;

        for window in cfs.windows(2) {
            total_pairs += 1;
            // Check if cf[i+1] = (cf[i] + 1) mod something
            // or cf[i+1] follows cf[i] in a predictable cycle
            let diff = (window[1] as i16 - window[0] as i16).rem_euclid(16);
            if diff == 1 || diff == 0 {
                sequential_pairs += 1;
            }
        }

        let sequential_ratio = sequential_pairs as f64 / total_pairs as f64;

        // Random: ~1/16 = 6.25% sequential
        // SixSix: ~100% sequential (cycling through nontrivial CFs)

        let cycling_detected = sequential_ratio > 0.5;

        DetectionSignal {
            detected: cycling_detected,
            confidence: sequential_ratio,
            details: format!(
                "Sequential CF pairs: {:.1}% (random ~6%, cycling ~100%)",
                sequential_ratio * 100.0
            ),
        }
    }

    /// Detect underused wire preference
    /// SixSix preferentially selects underused wires
    fn detect_underused_preference(circuit: &Circuit) -> DetectionSignal {
        if circuit.gates.len() < 50 {
            return DetectionSignal::none("Too few gates");
        }

        // Simulate what random selection would produce
        let n = circuit.num_wires;
        let g = circuit.gates.len();

        // Expected variance for random selection
        // Var(Binomial(n_gates * 3, 1/n_wires)) = n * p * (1-p)
        let p = 1.0 / n as f64;
        let expected_var = (g * 3) as f64 * p * (1.0 - p);

        // Actual variance
        let mut wire_counts = vec![0usize; n];
        for gate in &circuit.gates {
            for &pin in &gate.pins {
                if (pin as usize) < n {
                    wire_counts[pin as usize] += 1;
                }
            }
        }

        let mean = wire_counts.iter().sum::<usize>() as f64 / n as f64;
        let actual_var = wire_counts
            .iter()
            .map(|&c| (c as f64 - mean).powi(2))
            .sum::<f64>()
            / n as f64;

        // SixSix: variance is MUCH LOWER than expected (we balance usage)
        let variance_ratio = actual_var / expected_var;

        let preference_detected = variance_ratio < 0.3;

        DetectionSignal {
            detected: preference_detected,
            confidence: if preference_detected {
                1.0 - variance_ratio
            } else {
                0.0
            },
            details: format!(
                "Variance ratio: {:.2} (expected ~1.0, SixSix <0.3)",
                variance_ratio
            ),
        }
    }
}

#[derive(Debug, Clone)]
pub struct DetectionSignal {
    pub detected: bool,
    pub confidence: f64,
    pub details: String,
}

impl DetectionSignal {
    fn none(reason: &str) -> Self {
        Self {
            detected: false,
            confidence: 0.0,
            details: reason.to_string(),
        }
    }
}

#[derive(Debug)]
pub struct SixSixDetectionResult {
    pub is_sixsix: bool,
    pub detected_count: usize,
    pub total_signals: usize,
    pub confidence: f64,
    pub signals: Vec<(&'static str, DetectionSignal)>,
}

impl std::fmt::Display for SixSixDetectionResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "=== SixSix Pattern Detection (Attack #7) ===")?;
        writeln!(
            f,
            "Verdict: {}",
            if self.is_sixsix {
                "DETECTED [!]"
            } else {
                "Not detected"
            }
        )?;
        writeln!(f, "Signals: {}/{}", self.detected_count, self.total_signals)?;
        writeln!(f, "Confidence: {:.1}%", self.confidence * 100.0)?;
        writeln!(f, "")?;
        for (name, signal) in &self.signals {
            let status = if signal.detected { "[!]" } else { "[OK]" };
            writeln!(f, "  {} {}: {}", status, name, signal.details)?;
        }
        Ok(())
    }
}

/// Convert to standard AttackResult for suite integration
impl From<SixSixDetectionResult> for AttackResult {
    fn from(result: SixSixDetectionResult) -> Self {
        AttackResult::new(
            result.is_sixsix,
            result.confidence,
            format!(
                "SixSix pattern: {}/{} signals",
                result.detected_count, result.total_signals
            ),
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::six_six::{create_six_six_circuit, SixSixConfig};

    #[test]
    fn test_detect_sixsix_circuit() {
        let config = SixSixConfig::default();
        let circuit = create_six_six_circuit(&config);

        let result = SixSixDetector::detect(&circuit);
        println!("{}", result);

        // We WANT this to detect our pattern (that's the point of this test)
        println!("\nIf detected=true, our obfuscation is BROKEN.");
        println!("If detected=false, we have some security.\n");
    }

    #[test]
    fn test_detect_random_circuit() {
        let circuit = Circuit::random(64, 640);

        let result = SixSixDetector::detect(&circuit);
        println!("{}", result);

        // Random circuit should NOT be detected as SixSix
        assert!(
            !result.is_sixsix,
            "Random circuit should not be detected as SixSix"
        );
    }

    #[test]
    fn test_compare_sixsix_vs_random() {
        println!("=== Comparing SixSix vs Random ===\n");

        let config = SixSixConfig::default();

        let mut sixsix_detected = 0;
        let mut random_detected = 0;
        let trials = 20;

        for _ in 0..trials {
            let sixsix = create_six_six_circuit(&config);
            let random = Circuit::random(64, 640);

            if SixSixDetector::detect(&sixsix).is_sixsix {
                sixsix_detected += 1;
            }
            if SixSixDetector::detect(&random).is_sixsix {
                random_detected += 1;
            }
        }

        println!("SixSix circuits detected: {}/{}", sixsix_detected, trials);
        println!("Random circuits detected: {}/{}", random_detected, trials);
        println!();

        if sixsix_detected > trials / 2 {
            println!("[!] BROKEN: SixSix pattern is detectable!");
        } else {
            println!("[OK] SixSix pattern is not easily detectable");
        }

        if random_detected > 0 {
            println!("[!] FALSE POSITIVES: Random circuits detected as SixSix");
        }
    }
}
